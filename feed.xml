<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://stealthsoftwareinc.github.io/wizkit-blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://stealthsoftwareinc.github.io/wizkit-blog/" rel="alternate" type="text/html" /><updated>2022-11-14T15:14:05-05:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/feed.xml</id><title type="html">Team Wizkit</title><entry><title type="html">Evolving the SIEVE IR: Our Concrete Proposal</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2022/09/26/evolving-the-sieve-ir-our-concrete-proposal.html" rel="alternate" type="text/html" title="Evolving the SIEVE IR: Our Concrete Proposal" /><published>2022-09-26T00:00:00-04:00</published><updated>2022-09-26T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2022/09/26/evolving-the-sieve-ir-our-concrete-proposal</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2022/09/26/evolving-the-sieve-ir-our-concrete-proposal.html"><![CDATA[<div class="paragraph">
<p>Over this summer, Team Wizkit developed a concrete proposal for an overhaul of the SIEVE Intermediate Representation.
While our proposal is a fairly radical departure from the original IR, we believe this proposal addresses our concerns about wire memory management and interoperability in the presence of wide differentiation between backend capabilities.
In the upcoming months the SIEVE Program will internally agree upon a final draft for the Phase II IR, but we hope that sharing our IR proposal with the wider community will help others engage with the IR as it continues to evolve.</p>
</div>
<div class="paragraph">
<p>Before reading our new proposal, you may want to review our prior post to <a href="/wizkit-blog/2022/05/26/replacing-the-sieve-ir.html">contextualize the changes our team proposes</a>.
Then have a look at <strong><a href="/wizkit-blog/attachments/ir2/wizkit_ir_proposal.pdf">our new IR2 proposal here (PDF downoad)</a></strong>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><summary type="html"><![CDATA[Over this summer, Team Wizkit developed a concrete proposal for an overhaul of the SIEVE Intermediate Representation. While our proposal is a fairly radical departure from the original IR, we believe this proposal addresses our concerns about wire memory management and interoperability in the presence of wide differentiation between backend capabilities. In the upcoming months the SIEVE Program will internally agree upon a final draft for the Phase II IR, but we hope that sharing our IR proposal with the wider community will help others engage with the IR as it continues to evolve.]]></summary></entry><entry><title type="html">Getting Started with the SIEVE IR</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2022/08/04/getting-started-with-the-ir.html" rel="alternate" type="text/html" title="Getting Started with the SIEVE IR" /><published>2022-08-04T00:00:00-04:00</published><updated>2022-08-04T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2022/08/04/getting-started-with-the-ir</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2022/08/04/getting-started-with-the-ir.html"><![CDATA[<div class="paragraph">
<p>By now, you&#8217;ve read up on the SIEVE IR, you&#8217;re interested in ZK, and you&#8217;re ready to try it out the IR, but you&#8217;re not sure where to start.
For a ZK frontend, the IR opens up a world of backends, while for a backend it enables a wide variety of users to leverage your backend.
Well, here&#8217;s where to start: Team Wizkit has open sourced <a href="https://github.com/stealthsoftwareinc/wiztoolkit">WizToolKit</a> a collection of tools and libraries for working with the IR and <a href="https://github.com/emp-toolkit/emp-ir">EMP-IR</a> a ZK Backend which uses the IR.</p>
</div>
<div class="paragraph">
<p>For a ZK backend, a good place to start is with <a href="/wizkit-blog/2021/11/19/BOLT-two-pass-interpreter.html">WizToolKit&#8217;s BOLT API</a>.
BOLT is a callback-based API for handling ZK gates interpreted from the IR.
By implementing BOLT&#8217;s callbacks, your ZK Backend can easily and performantly ingest the SIEVE IR.
To get started check out our tutorials <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/backends.html">for using BOLT</a> and <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/parsers.html">for parsing the IR</a>.</p>
</div>
<div class="paragraph">
<p>For both frontends and backends, we have tools and demos to help you get started working the IR.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/tools/wtk-firealarm.html"><code>wtk-firealarm</code></a> can help you test and debug your IR circuits before you prove them in ZK. Its trace modes (<code>-t</code> or <code>-T</code> flags) can also help you sanity check when you&#8217;re struggling to debug your own ZK backends by printing out correct values for each wire in a circuit.</p>
</li>
<li>
<p><a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/tools/wtk-press.html"><code>wtk-press</code></a> can convert between the IR&#8217;s text and binary formats. It can also convert the IR&#8217;s <code>@switch</code> statements into multiplexer sub circuits&#8201;&#8212;&#8201;eliminating a large chunk of complexity for a backend.</p>
</li>
<li>
<p><a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/tools/wtk-viz.html"><code>wtk-viz</code></a> can convert an IR relation into a <a href="https://graphviz.org/">GraphViz</a> graph so that you can visualize your circuits.</p>
</li>
<li>
<p><a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/python/matrix_prod.py">The matrix product python script</a> can generate samples of the IR using various primes, test case sizes, and can switch between using loops or IR-Simple. Use these circuits to test and benchmark your backend and check out the source code for a demonstration of generating the IR.</p>
</li>
<li>
<p>Lastly, the <a href="https://github.com/emp-toolkit/emp-ir">EMP-IR</a> is a ZK backend ready for use with the IR. Test it out, or integrate it into your product.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the IR and our tooling sufficiently interests you, and you haven&#8217;t clicked away already then your best starting point is <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/install.html">the WizToolKit install guide</a> or <a href="https://github.com/emp-toolkit/emp-ir#installation">the EMP-IR install guide</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="WizToolKit" /><category term="SIEVE IR" /><category term="EMP" /><summary type="html"><![CDATA[By now, you&#8217;ve read up on the SIEVE IR, you&#8217;re interested in ZK, and you&#8217;re ready to try it out the IR, but you&#8217;re not sure where to start. For a ZK frontend, the IR opens up a world of backends, while for a backend it enables a wide variety of users to leverage your backend. Well, here&#8217;s where to start: Team Wizkit has open sourced WizToolKit a collection of tools and libraries for working with the IR and EMP-IR a ZK Backend which uses the IR.]]></summary></entry><entry><title type="html">Replacing the SIEVE Intermediate Representation</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2022/05/26/replacing-the-sieve-ir.html" rel="alternate" type="text/html" title="Replacing the SIEVE Intermediate Representation" /><published>2022-05-26T00:00:00-04:00</published><updated>2022-05-26T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2022/05/26/replacing-the-sieve-ir</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2022/05/26/replacing-the-sieve-ir.html"><![CDATA[<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#the-layered-approach">The Layered Approach</a></li>
<li><a href="#independent-functions">Independent Functions</a></li>
<li><a href="#switching-between-multiple-fields">Switching between Multiple Fields</a></li>
<li><a href="#encapsulated-datastructures">Encapsulated Datastructures</a></li>
<li><a href="#pulling-it-back-together">Pulling it Back Together</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>During most of 2021, the Wizkit team worked with other SIEVE Performers to develop and implement the SIEVE IR.
Since it was finalized during summer 2021, we continued to push the envelope beyond what was demonstrated during the Phase I Testing Event.
We&#8217;ve also been one of the most active voices, within the SIEVE program, critically analyzing this IR.
In this blog post, we put the results of the critique to good use in making design suggestions for the next IR revision.</p>
</div>
<div class="paragraph">
<p>As we enter Phase II, Wizkit&#8217;s intention is to approach this round of IR development without much emphasis on maintaining backwards compatibility.
In this redesign, our view is that the <em>biggest drawback</em> to rectify is the treatment of the IR as a clean hand-off from TA1 (the human-facing language) to TA2 (the ZK proof system).</p>
</div>
<div class="paragraph">
<p>To really illustrate this point, essentially every TA2 backend in the SIEVE program has a format that they would prefer over the IR.
Wizkit&#8217;s EMP backend prefers to encode its circuits in compiled C++, while our Virgo backend prefers to extract its own structuring from a non-uniform circuit, and yet other backends just want R1CS.
Additionally, as TA2s gain functionality (such as batch/vector optimization, free disjunctions, or ZK RAM), the IR must match that functionality, leaving behind gaps where the program must shift resources around the moving IR.</p>
</div>
<div class="paragraph">
<p>Similarly, the program has encountered a number of situations where prime-specificity in the IR has been an issue.
First, across certain backends, sharing the same prime is not possible.
Some backends (for example <a href="https://github.com/emp-toolkit/emp-zk">EMP&#8217;s QuickSilver</a>) require <a href="https://oeis.org/A000668">Mersenne Primes</a> while other backends (such as <a href="https://dl.acm.org/doi/pdf/10.1145/3372297.3417893">Ligero</a>) require <a href="https://oeis.org/A080076">Proth Primes</a> which enable FFTs.
These sets are disjoint (aside from 3).</p>
</div>
<div class="paragraph">
<p>To further complicate this, some circuits are specific to a prime.
For example, the size and layout of a Fermat&#8217;s Little Theorem multiplexer depends on its prime due to its use of the fast exponent algorithm.
Another prime specific circuit is the EC-DSA public key signature&#8201;&#8212;&#8201;its implementation requires the use of specific pair of primes.
Yet other circuits, such as business logic, are largely agnostic to the prime so long as it is sufficiently large to avoid overflow.</p>
</div>
<div class="paragraph">
<p>These complications over primes have become a concern of the IR within the SIEVE program.
To resolve these issues, the program has discussed a number of solutions.
A parameter negotiation could allow TA2 to indicate preferred primes to TA1.
TA2 could be required to embed unsupported prime fields into supported ones.
The IR could allow for unspecified primes or even ring ZK (e.g. mod 2<sup>n</sup>).
As we add prime generalities to the IR, the boundary between TA1 and TA2 is further blurred into a gray-zone where both sets of expertise are necessary.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-layered-approach">The Layered Approach</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With this in mind, our team encourages a two-layer approach to the IR.
The top layer, or translation IR (also referred to as "IR2"), has the semantics of translating to the bottom layer.
The bottom layer, or circuit abstraction, is a largely flat non-uniform circuit similar to IR-Simple or IR0 (at this point those two terms are largely interchangeable).
The translation becomes a gray area where TA1 and TA2 must cooperate to produce either the circuit abstraction or a more suitable ZK format.
We also acknowledge that the integrated front/back-end effort may opt to directly evaluate the translation IR.</p>
</div>
<div class="paragraph">
<p>A benefit of the translation is that it can overcome naturally occuring incompatibilities such as prime mismatches.
Say that TA1 calls for a prime that a given TA2 cannot support.
In IR1, this was generally a show-stopper.
However, for IR2, the translation is an ideal place to replace an arithmetic circuit with a multi-bit boolean circuit or to embed a prime in an alternate field, for example using <a href="https://ieeexplore.ieee.org/document/8418647">xJsnark</a>.
The same could be done with RAM reductions, for TA2s that don&#8217;t natively support RAM.
In this way, TA1 may remain involved even after their compiler has emitted valid IR, compensating for the IR&#8217;s movement into traditionally "TA1 territory", and gaining functionality in the process.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="independent-functions">Independent Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Functions in IR1 were heavily dependent on both the size of the circuit and the circuit&#8217;s underlying field.
In IR2, the program seeks to develop a standard library of common functionality which frontends can utilize and backends can optimize.
Obviously, one cannot consider a library standard if it is heavily tied to attributes of a particular circuit.</p>
</div>
<div class="paragraph">
<p>With this in mind, the translation IR needs to decouple from both fields/primes and circuit sizes.
Rather than generating a new matrix multiplier for each matrix size and each field, a single function should handle all combinations of field and matrix size.
In order for this to happen we need to reexamine the IR&#8217;s first-class datatypes.</p>
</div>
<div class="paragraph">
<p>In IR1, the only first-class was a wire, the medium for propagating field elements.
In IR2, we&#8217;ll need at least three first-classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Wires</p>
</li>
<li>
<p>Fields</p>
</li>
<li>
<p>Circuit size parameters such as publicly known lengths, arrays, and indices</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These three types are the minimum required to implement <em>any</em> standard library functionality.
In general, IR2&#8217;s core language should be the minimum feature set required to host its standard library.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="switching-between-multiple-fields">Switching between Multiple Fields</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A particular functionality, which both TA2s are beginning to support and TA1s are eager to adopt, is field switching&#8201;&#8212;&#8201;the ability for a backend to convert wires from one field to another within a single circuit.
Because field switching involves a single circuit mixing fields, this is a further reason to adopt a first-class field type.
To go with this a new conversion gate must also be added to the IR&#8217;s core.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="encapsulated-datastructures">Encapsulated Datastructures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The IR needs an aggregate type to enable to enable backends to implement and optimize their own datastructures.
Essentially, this type must expose custom behaviors while encapsulating implementation and data.
We&#8217;ve been calling this a <code>capsule</code> to distinguish from the object-oriented <code>class</code> terminology (although we&#8217;re still thinking about other potential names, like <code>abstraction</code> or <code>interface</code>).
While this <code>capsule</code> type would be polymorphic much like an object-oriented <code>class</code>, there is a key distinction.
A <code>capsule</code> is provided and overridden by the backend&#8201;&#8212;&#8201;the IR&#8217;s interpreter&#8201;&#8212;&#8201;whereas a <code>class</code> is overridden by subclasses in the same language.</p>
</div>
<div class="paragraph">
<p>The first formative example we have for this is for ring ZK.
The ring element is encapsulated by the <code>capsule</code>, hidden from the frontend.
The frontend interacts only with the <code>capsule</code>'s behaviors: addition, multiplication, etc.
The backends may provide alternative implementations or even replace with a native implementation.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-bottom">Multi-Bit Ring Implementation</th>
<th class="tableblock halign-left valign-bottom">Large-Field Ring Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-bottom"><div class="content"><div class="listingblock">
<div class="content">
<pre>capsule UInt32
  private bool bits[32];


  @method(add, /* ... */)
    /* boolean adder */
  @end
  @method(mul, /* ... */)
    /* boolean multiplier */
  @end
@end</pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-bottom"><div class="content"><div class="listingblock">
<div class="content">
<pre>capsule UInt32
  private BigField value;
  public currWidth;

  @method(add, /* ... */)
    /* add, with occasional renormalize */
  @end
  @method(mul, /* ... */)
    /* multiply, with occasional renormalize */
  @end
@end</pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>This pseudo code should illustrate the <code>capsule</code>, and how it may be polymorphized by the backend.
It is not meant to to illustrate IR2 syntax details; those are yet to be determined.</p>
</div>
<div class="paragraph">
<p>The second example we have is ZK RAM.
In this case, the IR can implement a very naive RAM-like structure, and the backend may either override a native ZK RAM implementation, use a circuit-manipulating RAM reduction during translation, or fall back to the naive implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>capsule RAM(Field Elt, Field Idx, public len)
  private Elt buffer[len];

  @method(get, @in: private Idx idx, @out: private Elt ret)
    ret &lt;- Elt(0);
    ctr &lt;- Idx(0);
    @for e in this.buffer (@modifies ret, ctr)
      ret += e * (ctr == idx);
      ctr += 1;
    @end
  @end

  @method(set, @in: private Idx idx, private Elt elt,
       @modifies: buffer)
    /* ... */
  @end
@end</pre>
</div>
</div>
<div class="paragraph">
<p>Again, the pseudocode is illustrative of the <code>capsule</code>'s naivety and the opportunity for backend optimization, rather than exact IR syntax.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pulling-it-back-together">Pulling it Back Together</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Our team is excited to make right some of what we see as the IR&#8217;s shortcomings.
We believe that pairing a translation IR with a circuit abstraction is the best solution to cover both varying ZK format preferences amongst TA2s and increased variety of new functionality amongst all TA2s.
In developing the IR we want its core to be as minimal a feature set as possible, whilst enabling common functionality to be implemented in shared and standard libraries.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><summary type="html"><![CDATA[During most of 2021, the Wizkit team worked with other SIEVE Performers to develop and implement the SIEVE IR. Since it was finalized during summer 2021, we continued to push the envelope beyond what was demonstrated during the Phase I Testing Event. We&#8217;ve also been one of the most active voices, within the SIEVE program, critically analyzing this IR. In this blog post, we put the results of the critique to good use in making design suggestions for the next IR revision.]]></summary></entry><entry><title type="html">BOLT, Two Pass IR Interpreter</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2021/11/19/BOLT-two-pass-interpreter.html" rel="alternate" type="text/html" title="BOLT, Two Pass IR Interpreter" /><published>2021-11-19T00:00:00-05:00</published><updated>2021-11-19T00:00:00-05:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2021/11/19/BOLT-two-pass-interpreter</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2021/11/19/BOLT-two-pass-interpreter.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In this installation about the SIEVE IR, we&#8217;re going to talk about speeding up a proof system without changing the underlying zero-knowledge mathemagic.
When we time a ZK backend using the IR we inadvertently time two distinct components&#8201;&#8212;&#8201;the backend itself and the time it takes to ingest a circuit.
The first component, the backend, is fairly well understood and many groups are working on optimizing this&#8201;&#8212;&#8201;faster math and less communication.
The second component is the topic of today&#8217;s post; it&#8217;s the time spent reading a gate and loading its operands before it can be processed in ZK.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If you&#8217;re looking for <em>how to use</em> BOLT, have a look at <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/backends.html">WizToolKit&#8217;s documentation for BOLT</a>. This post is about <em>how BOLT works</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We first looked into this problem after noticing that interpreting loops and functions was significantly slower in the IR than the IO and parsing time for an equivalent IR-Simple circuit&#8201;&#8212;&#8201;contrary to our expectation.
While some of the weaknesses outlined in our <a href="/wizkit-blog/2021/11/01/sieve-ir-v1.0-retrospective.html">IR Retrospective</a> certainly exacerbate the issue, we also stumble into the age old conflict of interpreters vs. compilers (Python vs. C, etc.).
While we have developed an extremely performant IR compiler, this post focuses on interpreters for the IR and takes half a step towards Just-In-Time (JIT) compilation.</p>
</div>
<div class="paragraph">
<p>The largest source of overhead which we encountered is searching for wires in lookup tables.
With loops and functions the lookup table must be built, destroyed and rebuilt on each iteration or invocation, causing significant slow downs.
We solve this problem by building an in memory data-structure where a single lookup table is built once and reused on many occurrences, and where each lookup operation is cached as a pointer into the table.
At the time of writing, we have already developed a partial prototype of this system.
This post will start out with results from the prototype in a non-ZK setting, then it will narrate development of the full system, and overview some results using the <a href="https://github.com/emp-toolkit/emp-zk">EMP-ZK backend</a>.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re unfamiliar with the SIEVE IR, you&#8217;ll want to read our <a href="/wizkit-blog/2021/09/20/introducing-the-sieve-ir.html">IR Introduction</a> and <a href="/wizkit-blog/2021/11/01/sieve-ir-v1.0-retrospective.html">Retrospective</a> before reading this.
You should also be prepared for some <a href="https://en.wikipedia.org/wiki/Mathematical_induction">proof by induction</a> and <a href="https://en.wikipedia.org/wiki/Unified_Modeling_Language">UML</a>.
We also clarify the following terms.
<strong>Overhead</strong>, in this context, is any time spent by a ZK proof system which isn&#8217;t directly related to the proof, so parsing and compiling or interpreting the circuit.
The <strong>parser</strong> is the first stage of processing the IR in which a sequence of characters matching the IR&#8217;s grammar is converted into a <strong>parse tree</strong> (or synonymously, syntax tree).
Both an IR compiler and interpreter will parse the IR, but the <strong>compiler</strong> will analyze the parse tree and produce an executable program which then performs the proof, while the <strong>interpreter</strong> will analyze the parse tree and perform a proof without an intermediate executable.
We further classify <strong>single-pass interpreters</strong> which immediately walk the parse tree and perform one step of the proof at each node, and <strong>multi-pass</strong> (or <strong>two, three, etc. -pass</strong>) <strong>interpreters</strong> which walk the tree multiple times, first doing analysis and building state data, then finally performing the proof.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prototype-and-early-results">Prototype and Early Results</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Our prototype succeeded in accelerating many samples of the IR, but it also entirely failed to interpret <code>@switch</code> statements and certain classes of <code>@for</code> loops.
Further we only developed it in a non-ZK setting.
That seems like a big failure for a supposedly ZK piece of equipment, but it gives us a lower bound the entire proof system&#8217;s runtime, e.g. how long would the proof take if ZK were entirely free.</p>
</div>
<div class="paragraph">
<p>After parsing, the prototype works in two phases.
First, the <strong>build phase</strong> analyzes the parse tree and rebuilds it with embedded lookup tables and cached pointers into those tables.
The build phase is able to embed most <em>public</em> semantics (such as "repeat this loop 5 times") into the tree.
Then the <strong>evaluate phase</strong> traverses the optimized parse tree and invokes a callback to handle each gate&#8217;s private semantics (such as "prove that `a * b == c`").
In the prototype we only implemented gate callbacks for the non-ZK setting, hence this limitation.</p>
</div>
<div class="paragraph">
<p>We were able to compare our BOLT prototype with <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/tools/wtk-firealarm.html">FIREALARM</a> (our non-ZK IR interpreter for debugging and development) as a single-pass baseline.
We used our <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/python/matrix_prod.py">matrix-multiply family of circuits</a> as test inputs to show scalability of this solution.</p>
</div>
<div class="paragraph">
<p>The figure compares runtimes for each phase of the IR processing solution, further broken down by the IR&#8217;s mode (simple or using loops).
It also shows target metrics for the SIEVE Program&#8217;s phases (arbitrary annual boundaries on our research).
During Phase II our target metric is 1 µs/gate, which I&#8217;ve converted to wall-clock time for the appropriate gate count (red with dots).
During Phase III our target metric is 0.1 µs/gate, again converted to wall-clock time (black with triangles).
Note that wall-clock time for a particular solution would be each of its phases summed together (e.g. parse time + firealarm time or parse time + build time + evaluate time).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/timing_motivation.png" alt="timing motivation">
</div>
<div class="title">Figure 1. Plot comparing the runtime of various phases in a FIREALARM or BOLT approach, <a href="/wizkit-blog/attachments/bolt/timing_motivation.csv">raw data</a></div>
</div>
<div class="paragraph">
<p>Before prototyping BOLT, the surprising result was that processing loops (orange with squares) was far slower than parsing (purple with vertical bars) and processing IR-Simple (aqua with stars).
End-to-end, the IR-Simple solution takes 0.121 µs/gate (purple with bars plus aqua with stars), which is just a bit shy of the Phase III target and leaves no time for actually performing the proof.
This discrepancy is what motivated us to develop BOLT.</p>
</div>
<div class="paragraph">
<p>The prototype improves upon this in a few respects.
First, parsing additional iterations of a loop does not add to the parsing time.
In fact, for this test case (and likely many others), parsing loops is a small constant runtime (green with cross, partially covered along the bottom).
As it turns out, the build phase is also a nearly-zero constant (yellow with squares, along the bottom).
This leaves the evaluate phase (blue with circles), which is on par with parsing or processing IR-Simple.
Overall, the BOLT prototype managed 0.061 µs/gate, which leaves a tight margin for performing the proof, but also has room for improvement.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="approach">Approach</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before getting into the design of BOLT, lets go over a quick example to animate the problem and how we solve it.
In the first animation, a vector dot product function of length 4 is shown.
Each frame traces a step of processing the sub-circuit in a single pass.
Many more frames show table lookups or insertions than show gate operations.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/single-pass-dotprod.gif" alt="Animation. It starts out showing an IR function with 1 output and 8 inputs wires. 4 multiplication gates multiply pairs of elements from the first 4 and last 4 input wires" width="then 3 addition gates sum the products. On each frame an arrow is draw from an element of the code to a table operation (lookup or insert) and then into a table. It starts out inserting two groups of four input wires" height="then the single output wire. Next">
</div>
<div class="title">Figure 2. A single pass interpreter processes a vector dot product.</div>
</div>
<div class="paragraph">
<p>Our second animation shows the approach of BOLT.
Rather than processing the parse tree directly, it is replaced with an alternate representation with pointers directly into a pre-built table.
On each gate, pointer reads and writes save time when compared to looking up or inserting to the table.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/multi-pass-dotprod.gif" alt="Animation. It starts out showing an IR-like function" width="however wire numbers in its body have been replaced with pointers. A memory table is also provided ahead of time. The function has 1 output and 8 input wires. 4 multiplication gates are shown followed by 3 addition gates. On each frame an arrow is drawn to or from one of the pointers from or to the table. It starts out by updating the table with two groups of four input wires. Then it updates a single wire reserved for function's output. Next" height="on each gate">
</div>
<div class="title">Figure 3. The BOLT interpreter processes a vector dot product.</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="design">Design</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before getting to the design, there are three numeric type abstractions.
The <code>wtk::index_t</code> (defined in <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/cpp/wtk/index.h"><code>wtk/index.h</code></a>) holds a wire-index, the <code>$</code> prefixed numbers indexing all wires in the IR.
The <code>wtk::index_t</code> is a simple <code>typedef</code> of <code>uint64_t</code>, thus capturing the <em>mod-2<sup>64</sup></em> behavior described for loop iterator-expressions and wire-numbers.
After that, BOLT is template-parameterized by the <code>Wire_T</code> and the <code>Number_T</code>.
The <code>Wire_T</code> is to encapsulate all values which the ZK Backend must carry between gates.
BOLT does not require it be a numeric type, although it is sometimes easy to think of it as such.
The <code>Number_T</code> holds field-literal values coming from the parser, before they&#8217;re mixed into <code>Wire_T</code>s.</p>
</div>
<div class="paragraph">
<p>BOLT has a pretty simple design at a high level.
BOLT connects <em>directives</em> directly to <em>wires</em> by rebuilding the IR syntax-tree and replacing the <code>wtk::index_t</code> indices with <code>Wire_T*</code> pointers.
The <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/cpp/wtk/IRTree.h">original syntax-tree</a> is fairly straight-forward, mirroring the grammar of the IR.
The BOLT structure is a bit more complicated and with wires being cross-referenced from "directive trees" to their storage space.</p>
</div>
<div class="paragraph">
<p>Directives are a simple tree-like structure, the <code>Bolt</code> struct (for lack of a better name) being the entry point.
For most directives, an "in-order" tree traversal should produce a correct evaluation.
When loops or function-gates are encountered, repetition of a particular sub-tree produces the correct evaluation (this will be elaborated in later subsections).
Wires are stored and looked up by the <code>WireSet</code> and <code>WireRange</code> families and connected to directives by the <code>WireRef</code> union-type.
The <code>WireRef</code> has two "addressing modes": <em>direct</em>, with a single pointer to a wire, and <em>indirect</em> with a pointer to and index in a <code>WireRange</code>.
BOLT does its best to use <em>direct</em> addressing as much as possible, however, <em>indirect</em> referencing is necessary when referencing for-loop iterator-expressions, or when reusing a function-gate at multiple call sites.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Two class-families are implemented as unions while shown as inheritance in UML (which conveniently pretends that unions do not exist).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Directives must be elements of the same list, even though they differ in function and purpose&#8201;&#8212;&#8201;not an "is a" relationship.</p>
</li>
<li>
<p><code>WireRef</code>s could use inheritance (and did in the original prototype), however as there are only two modes, the use of a union leads to a cleaner memory layout.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
BOLT (and WizToolKit in general) makes heavy use of a pool allocation pattern in which a "factory" or "builder" object produces some mess of structures, which take on the lifetime of the "factory".
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/UML_simple.png" alt="UML simple">
</div>
<div class="title">Figure 4. UML Diagram for BOLT (showing only simple directives). Along the top-left are the <code>WireRange</code> family, and along the bottom-right the <code>Directive</code> family. Connecting wires to directives the <code>WireRef</code> is above-center. The <code>Bolt</code> entry-point is pictured in the center-right, and its <code>WireSet</code> helper is below-center. Struct definitions can be found at <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/cpp/wtk/bolt/wires.h"><code>wtk/bolt/wires.h</code></a> and <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/cpp/wtk/bolt/directives.h"><code>wtk/bolt/directives.h</code></a></div>
</div>
<div class="paragraph">
<p>A <code>Builder</code> object (not shown) is responsible for translation of a single syntax-tree node (<code>wtk::DirectiveList</code>) into the BOLT structure.
If build succeeds, it guarantees that the relation, and consequently the produced BOLT structure, is well-formed and safe to evaluate.
The <code>Builder</code> optimizes the IR by analyzing one scope at a time.
In each scope, it follows these four steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Step 1: Reconstruct each scope&#8217;s memory layout.</p>
</li>
<li>
<p>Step 2: Preallocate space for wires.</p>
</li>
<li>
<p>Step 3: Rebuild each directive with pointers directly to preallocated space.</p>
</li>
<li>
<p>Step 4: Profit. (Well, okay. Execution of the scope will have a large constant-factor reduction in overhead)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Reconstruction is pretty simple.
We use a data structure which I&#8217;ve been calling a <em>SkipList</em> (although I&#8217;ve recently been informed that a <em>SkipList</em> is actually a multiply-linked-list with <em>O(log(n))</em> access time, which this is not).
My <em>SkipLists</em> are more like "ordered range sets": an ordered list of ranges (<code>first</code> and <code>last</code> pairs) which define membership.
Thus upon entry to any scope of the IR, the first thing to be done is to traverse all directives, and insert every assigned wire into a <em>SkipList</em>, the <em>"all list"</em>.</p>
</div>
<div class="paragraph">
<p>With all wires now accounted, they can be preallocated.
Local wires are to be allocated as <code>LocalWireRange</code>s in a <code>WireSet</code>.
The <code>WireSet.ranges</code> vector mirrors the structure of the local ranges within the <em>all list</em>.
Input and output wires are typically handled by the calling scope; we&#8217;ll cover them later.</p>
</div>
<div class="paragraph">
<p>Each directive is then rebuilt one by one.
At each directive, the wires must be checked, to ensure that the relation is indeed well-formed.
This is done with two additional <em>SkipLists</em>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>assigned</em></dt>
<dd>
<p>for wires which were assigned by previous directives.</p>
</dd>
<dt class="hdlist1"><em>deleted</em></dt>
<dd>
<p>to track <code>@delete</code>d wires.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Input wires must be members of the <em>assigned list</em> and non-members of the <em>deleted list</em>.
Output-wires are then inserted (with failure on duplication) into the <em>assigned list</em>.
Once the directive is deemed acceptable, each wire may be looked up and referenced: <code>Bolt.findWire(&#8230;&#8203;)</code> delegates to <code>WireSet.findRange(&#8230;&#8203;)</code> and <code>WireRange.ref(&#8230;&#8203;)</code>.</p>
</div>
<div class="paragraph">
<p>Most of the time, this will produce a pointer directly to the wire, allowing the evaluation phase to skip out on safety-checks and lookup costs.
<em>Evaluation</em> can still be considered safe, because the <em>Build</em> phase would have aborted before producing an unsafe pointer.
The performance gain is especially effective with loops, because repetition allows a single directive to be reused many times.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="remapping-wires-between-scopes">Remapping Wires Between Scopes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In lieu of a conventional lexical scoping scheme, the IR uses a local scoping scheme with "remapping" from the calling scope to a local scope.
Variances in remapping lead to a family of <code>WireRange</code>s, responsible for handling various cases of remapping.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Local</dt>
<dd>
<p>has ownership over a vector of wires in the local-scope. Lookup is performed via vector-indexing.</p>
</dd>
<dt class="hdlist1">Direct</dt>
<dd>
<p>is the simplest form of remapping, with a pointer into a containing scope&#8217;s local-scope. Lookup is performed via pointer-offset.</p>
</dd>
<dt class="hdlist1">Indirect</dt>
<dd>
<p>holds a pointer to another <code>WireRange</code>, to which all functionality is delegated.</p>
</dd>
<dt class="hdlist1">WireSet</dt>
<dd>
<p>Similar to <em>Indirect</em>, however it delegates to a <code>WireSet</code> rather than a <code>WireRange</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>Builder</code> takes the responsibility for checking that any <code>WireRange</code> is safe to dereference before it is built.
In other words, the construction of an unsafe <code>WireRange</code> would be indicative of a poorly-formed relation.
Each <code>WireRange</code> has three essential functionalities which the <code>Builder</code> must guard.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>producing a reference to a single wire (<code>ref(single)</code>),</p>
</li>
<li>
<p>producing a <code>WireRange</code> reference to itself or a subset of itself (<code>ref(range)</code>),</p>
</li>
<li>
<p>and dereferencing single wires within itself, as a requirement for <em>Indirect</em> referencing schemes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dashed arrows in the UML are used to indicate each <code>WireRange</code>'s means of reference.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/UML_functions.png" alt="UML functions">
</div>
<div class="title">Figure 5. UML Diagram for BOLT, simple directives are replaced with <code>AnonFunction</code>, <code>Function</code>, and <code>Invocation</code>. Additional <code>WireRange</code> forms are shown as needed for function gates.</div>
</div>
<div class="paragraph">
<p>The goal for BOLT is to produce as many <em>direct</em> references as possible.
In the following sub-sections, we&#8217;ll get into the remapping for each of the non-simple IR1 directives, starting from least to most complicated.</p>
</div>
<div class="sect2">
<h3 id="anonymous-function">Anonymous Function</h3>
<div class="paragraph">
<p>Anonymous functions are the easiest to remap, because they are used exactly once.
First, the caller will check for usability of the input wires in the <em>assigned</em> and <em>deleted SkipLists</em>, and then for assignability of the output wires.
When it knows the function is safe to call, it produces <em>direct</em> references for its local wires, and polymorphism&#8201;&#8212;&#8201;within its own remapped wire ranges&#8201;&#8212;&#8201;produces the simplest remapping it can for previously-remapped wires.</p>
</div>
</div>
<div class="sect2">
<h3 id="named-function">Named Function</h3>
<div class="paragraph">
<p>Named functions are slightly more difficult than anonymous ones, because they may be reused multiple times.
To save time during the build phase, we want to reuse the <code>Bolt</code> structure built for the function.
To do this, remapping must be split between the function-body and each invocation.</p>
</div>
<div class="paragraph">
<p>In the function-body, a placeholder wire range is mapped into the the <code>Bolt</code> body.
A <code>WireSetWireRangeRef</code> is used, with a <code>WireSet*</code> pointer initialized to null.
The placeholder creates <em>Indirect</em> references to itself, so that the body can be built.
During evaluation, the <code>WireSet*</code> pointer is changed to non-null so that actual wires can be referenced.</p>
</div>
<div class="paragraph">
<p>At the invocation site, wires from the caller&#8217;s scope are mapped into a <code>WireSet</code> using the similar rules to an Anonymous Function.
At evaluation time, this <code>WireSet</code> is pointed to by the function&#8217;s placeholder.</p>
</div>
</div>
<div class="sect2">
<h3 id="switch-statement">Switch Statement</h3>
<div class="paragraph">
<p>IR switch statements differ from conventional switches because all <code>@case</code>s must be processed to hide the switch condition wire.
After processing all <code>@case</code>s the output wires from the <em>selected</em> <code>@case</code> is multiplexed onto the <code>@case</code>'s output wires.
This is complicated by <code>@assert_zero</code> directives, which are disabled in <em>non-selected</em> <code>@case</code>s and by <code>@instance</code> and <code>@short_witness</code> directives which must share input values across cases to avoid blowup in the stream size.</p>
</div>
<div class="paragraph">
<p>Building and evaluating a switch statement is sort of a three step process.
Remember that each <code>@case</code> has its own input list (as either a named or an anonymous function), but all <code>@case</code>s share the <code>@switch</code>'s output list.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Each <code>@case</code>'s Instances and Witnesses counted and the maximum is taken as the <code>@switch</code>'s output count.</p>
<div class="ulist">
<ul>
<li>
<p>During evaluation, the <code>@switch</code> consumes inputs which are routed to <code>@instance</code> and <code>@short_witness</code> directives within the switch.</p>
</li>
</ul>
</div>
</li>
<li>
<p>"Dummy" output wires and "legitimate" input wires are mapped into each <code>@case</code>'s body.</p>
</li>
<li>
<p>During evaluation, after all <code>@case</code>s are evaluated, the dummies are multiplexed into the legitimate outputs.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Step one happens dynamically during evaluation, aside from counting the maximum consumption of instance and witness wires.
The <code>@switch</code> will consume all the necessary inputs and places them in a special buffer (<code>SwitchInputHandler</code>).
The body of each <code>@case</code> is given a pointer to the buffer in place of the normal streams (<code>wtk::InputStream</code>).
<code>@instance</code> and <code>@short_witness</code> directives copy wires from the buffer rather than consuming from the stream.</p>
</div>
<div class="paragraph">
<p>Step two is again fairly straight forward.
As each <code>@case</code> has none of its own output wires (only the <code>@switch</code>'s, at a top level), the total number of outputs can be counted, and a <code>LocalWireRange</code> may be allocated as "dummy" space for each <code>@case</code>.
Then the input wires can be mapped in, and processing of each <code>@case</code> continues the same as it would for a standard <code>@call</code> or <code>@anon_call</code>.
When processing the body during evaluation, a special <em>case-enabled</em> wire is carried to toggle inputs to <code>@assert_zero</code> directives.</p>
</div>
<div class="paragraph">
<p>The last step of build remaps each of the <code>@switch</code>'s outputs to a special <em>output</em> <code>WireSet</code>.
At evaluation, the dummy wires are multiplexed, and each result is assigned to the corresponding wire in the <em>output</em> <code>WireSet</code>.
The BOLT system defaults to the <em>Fermat&#8217;s Little Theorem</em> trick described in section 6.3 of the IR spec.
However, ZK backends could improve upon this with dynamic generation of additional witness values.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/UML_switches.png" alt="UML switches">
</div>
<div class="title">Figure 6. UML Diagram for BOLT&#8217;s switch-statement implementation. The <code>SwitchStatement</code> type relies on <code>Invocation</code> and <code>AnonFunction</code> for each case, along with a <code>SwitchInputHandler</code> that manages reuse of instance and witness values.</div>
</div>
</div>
<div class="sect2">
<h3 id="for-loops">For Loops</h3>
<div class="paragraph">
<p>For loops are where wire-remapping gets <strong>really</strong> tricky, because the remapping indexes change on each iteration, due to iterator-expressions and iterator-expression-ranges
(from now on I will use "expression" synonymously with "iterator-expression" and "iterator-expression range", as a single "iterator-expression" is simply a range with a constant span of 1).
BOLT has three code paths for processing a loop.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Shortcut</strong>, where the well-formedness of its iterations may be extrapolated from its bounds.</p>
</li>
<li>
<p><strong>Soft Unrolling</strong>, where each iteration has its remapping tested individually, but all iterations share the same body.</p>
</li>
<li>
<p><strong>Hard Unrolling</strong>, where each iteration has an individual remapping and body.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Shortcut and soft unrolling can be applied in a hybrid fashion where some expressions are shortcut and others are soft unrolled.
Unfortunately, hard unrolling is an all-or-nothing deal.</p>
</div>
<div class="paragraph">
<p>IR specification compliance can be summarized to a few simple heuristics.
However, the general case requires most of them be checked on each iteration.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Every input wire in every iteration must have been assigned previously.</p>
<div class="ulist">
<ul>
<li>
<p>Assignment could be before the loop,</p>
</li>
<li>
<p>Or in a prior iteration of the loop.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Every output wire in every iteration of the loop must be assignable.</p>
</li>
<li>
<p>The union of all iterations' outputs must be equal to the entire loop&#8217;s outputs.</p>
</li>
<li>
<p>Lastly, either the named function must receive the correct number of inputs and outputs, or the anonymous body must itself be well-formed on all iterations.
Typically, the latter requires that all iterations have the same number of inputs and outputs.</p>
<div class="ulist">
<ul>
<li>
<p>There are some exceptions to having same-sized iterations, however these should be uncommon enough to be penalized by unrolling.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="detecting-shortcuts">Detecting Shortcuts</h4>
<div class="paragraph">
<p>BOLT does its best to come up with specific cases which it can shortcut, and attempts to fall back to unrolling as infrequently as possible.
A trivial shortcut rule is if an input expression is constant and is assigned entirely before the loop.
The non-trivial shortcuts will interpolate a total range (minimum through maximum values) for each expression, and show that the entire range is either referencable for inputs or assignable for outputs.
To do this it has the following conditions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This isn&#8217;t to say that an extrapolation couldn&#8217;t be made with different conditions. These ones happen to be a fairly straight-forward baseline, and to cover many common cases of loops.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">The expression must be a linear expression.</dt>
<dd>
<p>For a linear expression, the expression&#8217;s minimum and maximum values (forming the total range) will occur at a loop bound.
This is also a prerequisite for later conditions.</p>
<div class="ulist">
<ul>
<li>
<p>A sub condition is that evaluation at bounds must not cause integer overflow.
Integer overflow would cause a discontinuity, meaning the minima and maxima may occur on a middle iteration.
Inductively, if a middle iteration causes overflow, then either the next or previous iteration would cause overflow until a bound is met.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">The expression must have the same span at the loops' bounds.</dt>
<dd>
<p>(including combinations of outer-loops' bounds, if the expression depends on outer-loop iterators) If all expressions meet this condition, then each iteration must have the same number of outputs and inputs.</p>
<div class="ulist">
<ul>
<li>
<p>As a sub-condition, the expression&#8217;s span must be 1 or more, to respect well-formedness rules.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">The <em>output</em> expression must have adjacent first and second iterations (or the loop may have only one iteration).</dt>
<dd>
<p>(e.g. <em>i<sub>1</sub>.last == i<sub>2</sub>.first - 1</em> or <em>i<sub>1</sub>.first == i<sub>2</sub>.last + 1</em>) If this is the case, then the expression&#8217;s total range is uninterrupted and can be used to check that the loop&#8217;s outputs are covered.</p>
<div class="ulist">
<ul>
<li>
<p>As a condition of the loop, all output expressions must have disjoint total-ranges, but their union must be equal to the loop&#8217;s output.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">The <em>output</em> expression may depend only on the local loop iterator.</dt>
<dd>
<p>If the loop itself is repeated by an outer loop, then outputs may be remapped correctly in one iteration and incorrectly in another iteration.
Non-dependence on surrounding loop-iterators eliminates that possibility.</p>
</dd>
<dt class="hdlist1">The <em>input</em> expression&#8217;s total range must be assigned before the loop.</dt>
<dd>
<p>When the expression&#8217;s total range is assigned prior to the loop, well-formedness can be checked in the <em>assigned</em> and <em>deleted SkipLists</em>.</p>
<div class="ulist">
<ul>
<li>
<p>Failing this, the <em>input</em> expression&#8217;s total range must intersect with some <em>output</em> expressions ranges.
Both the <em>input</em> expression and the <em>output</em> expressions must be soft unrolled.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
An interesting side-effect of checking all these conditions is that they indicate that each iteration of the loop is independent of the others.
That means that the loop could be parallelized or batch-amortized (however, as-built BOLT is definitely <strong>not</strong> thread-safe).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cutting-corners-on-sequential-loops">Cutting Corners on "Sequential" Loops</h4>
<div class="paragraph">
<p>The last condition of shortcut processing (that <em>input</em> expressions' total ranges must be preassigned) excludes a large class of "sequential" loops which could otherwise shortcut.
In a "sequential" loop, an input expression follows closely behind an output wire, meaning that while it isn&#8217;t <em>pre</em>assigned, it is assigned before use.
These forms can be detected when an <em>input</em> expression&#8217;s total range overlaps an existing <em>output</em> expression&#8217;s total range.
In this case, the following additional conditions allow us to continue shortcut processing rather than soft unrolling.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">The <em>input</em> expression must depend only on the local iterator.</dt>
<dd>
<p>This mirrors the condition of an <em>output</em> expression and assures consistent behavior across iterations of an outer loop.</p>
</dd>
<dt class="hdlist1">The difference between evaluations of <em>output</em> and <em>input</em> expressions at the loop bounds must be the same.</dt>
<dd>
<p>This ensures that both expressions have the same "total span", meaning that one won&#8217;t advance ahead of the other (because we already know that the expressions are linear and have constant span).</p>
</dd>
<dt class="hdlist1">The <em>output</em> and <em>input</em> expressions must "travel" in the same direction</dt>
<dd>
<p>If the expressions were to "travel" in opposite directions, then the <em>input</em> expression would be unassigned until the expressions "crossed their midpoint".</p>
</dd>
<dt class="hdlist1">There must exist a difference between the <em>input</em> and <em>output</em> expression&#8217;s total ranges which is assigned before the loop, and which covers the span of the first iteration of the <em>input</em> expression.</dt>
<dd>
<p>If this preassigned space did not exist, or if it did not cover the first iteration, then the first iteration of the loop would have a poorly formed <em>input</em> expression.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="building-the-shortcut-loop">Building the Shortcut Loop</h4>
<div class="paragraph">
<p>When these conditions are met BOLT builds a single loop body with special wire ranges to self-update on each iteration.
The loop&#8217;s body is a single <code>Bolt</code> object (rather than an <code>Invocation</code> or <code>AnonFunction</code> as <code>SwitchStatement</code> does), essentially inlining any named functions.
This mainly saves on code-complexity, at the occasional expense of memory usage, but it also avoids adding another layer of <code>WireSetWireRangeRef</code>.</p>
</div>
<div class="paragraph">
<p>Each expression is remapped as one of <code>ShortcutLoopIndirectWireRangeRef</code>, <code>ShortcutLoopWireSetWireRangeRef</code>, or, in the case of <em>constant input</em> expressions, remapped as-is.
<code>ShortcutLoop<em>XX</em>WireRangeRef</code>s have a constant range within the inner-scope of the loop, but reevaluate their expression on each iteration of the loop, redefining an offset into the outer-scope.
In most cases the inner-scope range can hold a single pointer to a contiguous outer-scope range ("<em>Indirect</em>").
However, it is possible for an expression to cross between ranges of the outer-scope (say from the input-wires into some local wires), thus a <em>WireSet</em> range must search the entire calling-scope.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/UML_shortcut.png" alt="UML shortcut">
</div>
<div class="title">Figure 7. UML Diagram for Shortcut Loops. Along the left are the <code>ShortcutLoop<em>XX</em>WireRangeRef</code> types. The <code>Expr</code> type, a simple stack-calculator for updating expressions, is defined in the bottom left corner. The <code>ForLoop</code> directive is defined along the bottom.</div>
</div>
</div>
<div class="sect3">
<h4 id="soft-unrolling-path">Soft Unrolling Path</h4>
<div class="paragraph">
<p>Soft unrolling uses some of the same <em>SkipLists</em> from earlier to check the assignment of each wire-range on each loop iteration.
If any of the expressions being unrolled depend on a non-local iterator, then soft unrolling must check the expression at each iteration of the non-local iterator to assure that the inner-loop is well-formed on every iteration of the outer-loop.
Soft unrolling must also check for variable sized inputs or outputs, which would cause BOLT to fall back to hard unrolling.</p>
</div>
<div class="paragraph">
<p>When soft unrolling succeeds, a single <code>SoftLoopWireRangeRef</code> is mapped into the sub-scope.
It holds a vector of <code>Translation</code>s which can be searched to map an inner-scope range to an offset in the outer-scope.
On each iteration of the loop a <code>Mapping</code> must update each <code>Translation</code>, as the span could change.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/UML_soft.png" alt="UML soft">
</div>
<div class="title">Figure 8. UML Diagram for soft unrolled loops. In the bottom left quadrant are the <code>SoftLoopWireRangeRef</code> family with <code>Translation</code> which when given an inner-scope index finds the outer-scope index and <code>Mapping</code> which updates the <code>Translation</code>s on each call to <code>update()</code>.</div>
</div>
</div>
<div class="sect3">
<h4 id="hard-unrolling-path">Hard Unrolling Path</h4>
<div class="paragraph">
<p>In the hard unrolling path, BOLT falls back to a single-pass interpretation scheme.
One property this must maintain is that the build phase is expected to catch any relation well-formedness issues.
For this reason the hard unroll path "pre-executes" the entire loop (repeating for any outer-loops) during the build phase, double-penalizing TA1 for emitting such an obnoxious loop (and myself for allowing such a loop in the IR at all ;-).</p>
</div>
<div class="paragraph">
<p>The main reason that hard unrolling would occur is due to a loop where the output list or input list has non-constant size.
BOLT cannot handle this because the <code>WireRef</code> cannot cache such a dynamic reference.</p>
</div>
<div class="paragraph">
<p>An example of hard unrolling is the "square loop" example.
It is a pair of nested loops.
The inner loop is fairly standard with 100 iterations and assigning its output range in 99, 98 &#8230;&#8203; 0 order.
The outer loop, however, assigns its 100 outputs in 10 iterations, where each iteration&#8217;s output size increases with the iterator&#8217;s square.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$0 ... $99 &lt;- @for i @first 0 @last 9
  // Range is based on square(i), rather than simply i.
  $(i * i) ... $(((i + 1) * (i + 1)) - 1) &lt;- @anon_call(@instance:0, @short_witness:1)
    $100 &lt;- @short_witness;
    // This inner fills some locals and the output list
    $0 ... $99 &lt;- @for j @first 0 @last 99
      $(99 - j) &lt;- @anon_call($(100 - j), @instance:0, @short_witness:0)
        $0 &lt;- @mul($1, $1);
      @end
    @end
  @end
@end</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="the-expr-stack-calculator">The <code>Expr</code> Stack Calculator</h4>
<div class="paragraph">
<p>The <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/cpp/wtk/bolt/Expr.cpp#L15"><code>Expr</code> stack calculator</a> updates offsets and mappings in BOLT Loops.
Although this article has used "expression" to refer to an "expression range" the <code>Expr</code> type implements only one bound of the range (e.g. two are needed to represent the entire range).</p>
</div>
<div class="paragraph">
<p>Initially the <code>Expr.eval()</code> method took nearly 50% of BOLT&#8217;s non-ZK runtime, however we were able to optimize this to about 15% to 20%.
Here are a few of its optimization tricks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Passing the stack as a parameter eliminates allocation (faster than even stack-allocation, don&#8217;t ask me why, but C++ doesn&#8217;t like arrays on its stack). This optimization was done to the BOLT Prototype, nearly doubling its speed.</p>
</li>
<li>
<p>"Offset" and "multiple" operations push two parameters to the stack (<code>term.literal</code> and <code>*term.iterator</code>, which were originally union members) before performing either an addition or multiplication. This saves two iterations of the calculator.</p>
</li>
<li>
<p>A common case of the calculator is that it returns after just a single iteration (especially with offset and multiple operations). So we made these a fast-path which skips the stack entirely.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="results">Results</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;re quite pleased with the results from BOLT.
The full-scale system does manage to improve upon the prototype: in the non-ZK setting it managed 4.3s compared to about 5.2s for the matrix 350 circuit, and I believe this was even with a larger prime.
But more important are the metrics with a ZK Backend.
We implemented BOLT&#8217;s callback API using the <a href="https://github.com/emp-toolkit/emp-zk">EMP QuickSilver backend</a>.
When BOLT&#8217;s evaluate phase reaches each gate, it invokes a method from the from the <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/backends.html#the-backend-api"><code>wtk::bolt::Backend</code></a> abstract class.
Child classes can override these methods to perform each gate using ZK.</p>
</div>
<div class="paragraph">
<p>For fair comparison with other approaches we developed the single-pass <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/backends.html#invoking-plasmasnooze">"PLASMASnooze" interpreter</a> (a pun on FIREALARM) which shares backend integrations with BOLT.
We also developed a streaming IR-Simple PLASMASnooze implementation.
As IR-Simple&#8217;s syntax tree is a flat list, each gate can be processed immediately and then discarded, rather than storing it in a parse tree for later traversal.
Lastly we also compare with the <a href="https://github.com/emp-toolkit/emp-ir">EMP C++ compiler</a> which translates the IR to C++.
We&#8217;ve plotted the end to end time (from IR to valid proof) for these approaches using the matrix circuit.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/timing_results_matrix.png" alt="timing results matrix">
</div>
<div class="title">Figure 9. Matrix Circuit EMP Results (Linear time scale from 0 to 110)</div>
</div>
<div class="paragraph">
<p>As expected, the IR-Loops single-pass (teal with crosses) is far slower than the IR-Simple in streaming mode (purple with plus signs).
However the BOLT implementation (blue with stars) is 2x faster than streaming and the C++ implementation (orange with squares) is naturally even faster than that.</p>
</div>
<div class="paragraph">
<p>We also tested against the Finite State Machine circuit created by the T&amp;E Team, which tests IR switch statements.
Unfortunately, we don&#8217;t have an IR-Simple version of this circuit, however we have a few interesting comparisons to make between the IR-Switch FSM circuit and its equivalent after switch statements were converted to multiplex circuits.
Additionally, the EMP backend can improve upon the Fermat multiplexer by creating and checking an additional witness value.
Unfortunately, we had issues compiling larger instances of the FSM circuit with EMP C++, due to <code>gcc</code> running out of RAM.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/timing_results_fsm.png" alt="timing results fsm">
</div>
<div class="title">Figure 10. Finite State Machine EMP Results (Log time scale from 5 to 12,000 seconds)</div>
</div>
<div class="paragraph">
<p>There are a few interesting takeaways from these test cases.
Most notably, single-pass switch, multi-pass multiplexer, and multi-pass switch are clustered fairly tight (yellow, orange, and green overlaps).
These all took between 8.4 and 8.8ks on the largest test-case.
This indicates that in the multi-pass interpreter the <code>@switch</code> directive is only a marginal improvement over a hard-coded multiplexer.
In the single-pass interpreter, however the <code>@switch</code> directive was extremely effective, going from over 11ks down to about 8.8ks.</p>
</div>
<div class="paragraph">
<p>The most dramatic gain, however, is from replacing the Fermat multiplexer with a witness-checking multiplexer ("EMP-Tricks").
These improve upon the Fermat multiplexer with an approximately 11x speedup.
In this case, the largest test case runs in 826s for the single-pass (aqua with stars) and multi-pass (blue with circles) further improves that by about 10% to 748s.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We designed and developed the BOLT system after noticing that our compact IR-Loop circuits were much slower than their flat/non-uniform equivalents.
We wanted to understand and avoid this slowdown.
The BOLT system accomplished this goal, helping us understand how time was being spent between ZK gates.
In the process, we managed to improve significantly upon flat circuits.
Overall, we hope that following along with our BOLT development has given the reader an appreciation for the overhead spent between ZK gates and some insight into optimizing both ZK circuits and backends.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re interested in using BOLT to speed up your own ZK backend when using the SIEVE IR, have a look at <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/backends.html">the WizToolKit tutorial for integrating backends</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><category term="WizToolKit" /><summary type="html"><![CDATA[In this installation about the SIEVE IR, we&#8217;re going to talk about speeding up a proof system without changing the underlying zero-knowledge mathemagic. When we time a ZK backend using the IR we inadvertently time two distinct components&#8201;&#8212;&#8201;the backend itself and the time it takes to ingest a circuit. The first component, the backend, is fairly well understood and many groups are working on optimizing this&#8201;&#8212;&#8201;faster math and less communication. The second component is the topic of today&#8217;s post; it&#8217;s the time spent reading a gate and loading its operands before it can be processed in ZK.]]></summary></entry><entry><title type="html">SIEVE IR v1.0 Retrospective</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2021/11/01/sieve-ir-v1.0-retrospective.html" rel="alternate" type="text/html" title="SIEVE IR v1.0 Retrospective" /><published>2021-11-01T00:00:00-04:00</published><updated>2021-11-01T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2021/11/01/sieve-ir-v1.0-retrospective</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2021/11/01/sieve-ir-v1.0-retrospective.html"><![CDATA[<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#what-did-we-get-right">What Did We Get Right?</a></li>
<li><a href="#where-can-we-improve">Where can we Improve?</a>
<ul class="sectlevel2">
<li><a href="#large-discontinuities-in-wire-numbers">Large Discontinuities in Wire Numbers</a></li>
<li><a href="#consecutive-discontiguities">Consecutive Discontiguities</a></li>
</ul>
</li>
<li><a href="#what-else-is-missing">What Else is Missing?</a></li>
<li><a href="#conclusions">Conclusions</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In our previous post we took a first look at the SIEVE IR, presenting it as impartially as possible.
Today we will take a more "opinionated" or normative look at the IR.
On the one hand, we are very proud of this accomplishment&#8201;&#8212;&#8201;(to our knowledge) the first widely implemented circuit representation for ZK.
However, we&#8217;d also like to acknowledge that the IR has its flaws and highlight where we think there is room for improvement.</p>
</div>
<div class="paragraph">
<p>If you understood the previous <a href="/wizkit-blog/2021/09/20/introducing-the-sieve-ir.html">introduction post</a>, then you should be in a good position to read this one too.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="what-did-we-get-right">What Did We Get Right?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Looking at the goals we set out for the IR, here&#8217;s where we think it is a success.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Backend Interoperability</dt>
<dd>
<p>The IR is successfully integrated with every ZK backend in the SIEVE program.
This means that so long as two backends can share the same prime, they can prove the same witnessed statement.
The T&amp;E Team was even able to use the SIEVE profile of zkInterface to convert from the IR to R1CS and use <a href="https://github.com/scipr-lab/libsnark"><code>libsnark</code></a> as a testing baseline.</p>
</dd>
<dt class="hdlist1">Succinct Relations</dt>
<dd>
<p>The IR enables a relatively short relation to expand into a far "longer" (at least in gate count) proof.
This means that a given relation in the IR may be far shorter than its equivalent in, say, Bristol Fashion or R1CS.</p>
</dd>
<dt class="hdlist1">Interoperable Text and Binary</dt>
<dd>
<p>This is sort of an odd-ball feature of the IR, but from the start we realized that an IR has two potentially conflicting goals:
On the one hand, it must enable developers to reason about and debug their work, as well as to educate their peers and students.
However, it must also be performant enough for large-scale systems.
Thus, rather than scarifice either of these goals in service of the other, we came up with a text format for humans (as well as computers) to read, and a binary format that computers can ingest on the fly if desired.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>To illustrate some of these advantages, we&#8217;ll introduce the matrix-multiplication circuit that we&#8217;ve used extensively for testing.
The circuit is given three matrices <em>A</em>, <em>B</em>, and <em>C</em> over some finite field <em>GF(p)</em> of prime order <em>p</em>.
<em>A</em> and <em>C</em> are of the instance (visible to the verifier), while <em>B</em> is from the witness (a secret of the prover).
The circuit computes <em>C' := A * B</em> and proves that <em>C == C'</em>.</p>
</div>
<div class="paragraph">
<p>The circuit is generated by a <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/v1.0.1/src/main/python/matrix_prod.py">Python script</a>.
It is parameterized by the matrix size, the prime <em>p</em>, and the choice of whether to generate a non-uniform/flat circuit ("IR0") or to use loops for shrinking the circuit&#8217;s size ("IR1").
The on-disk size of the IR0 circuit is cubic in the size of the matrix, whilst that of IR1 is nearly constant.</p>
</div>
<div class="paragraph">
<p>During the Phase I testing event, every TA2 backend of the SIEVE program was able to prove satisfiability of the matrix-multiplication circuit under one or more primes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="where-can-we-improve">Where can we Improve?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Early in the program the IR started out as largely a ZK-friendly analog to Bristol Fashion (with an arithmetic profile), and at that time the decision was made that all wires in a circuit would be numbered.
This numbering system made sense when there was a single scope with many, many wires in it.
However, we&#8217;ve since extended to nested scopes with repetition and branching, and the numbering system is starting to push its limits.</p>
</div>
<div class="paragraph">
<p>At this point the largest issue is that the wire-numbering system cannot express memory boundaries, and even if it could, it cannot enforce them.
Due to the numbering system and its extensions, long discontinuities may arise between wire numbers, and consecutively numbered wires might refer to discontiguous space.</p>
</div>
<div class="sect2">
<h3 id="large-discontinuities-in-wire-numbers">Large Discontinuities in Wire Numbers</h3>
<div class="paragraph">
<p>The IR defines wire numbers as being in the range of 0 through 2<sup>64</sup>-1.
Most of the time a frontend will generate them consecutively starting at 0, but this is not required.
This means that one could generate a circuit without consecutive wire numbering, and the ZK backend must deal with it.
The example here is the <a href="/wizkit-blog/2021/09/20/introducing-the-sieve-ir.html#a-streaming-modification">triangle example</a> that&#8217;s been used in a few places; however, we&#8217;ve replaced some of the wires with random numbers between 0 and 2<sup>64</sup>-1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>version 1.0.0;
field characteristic 127 degree 1;
relation
gate_set: arithmetic;
features: simple;
@begin
  $9596288231981551893 &lt;- @instance;
  $3 &lt;- @mul($9596288231981551893, $9596288231981551893);
  $1 &lt;- @instance;
  $86792020199 &lt;- @mul($1, $1);
  $11117553 &lt;- @short_witness;
  $12294742782356752208 &lt;- @mul($11117553, $11117553);
  $6 &lt;- @add($3, $86792020199);
  $7 &lt;- @mulc($12294742782356752208, &lt;126&gt;);
  $8 &lt;- @add($6, $7);
  @assert_zero($8);
@end</pre>
</div>
</div>
<div class="paragraph">
<p>This is admittedly a bit of an absurd example.
But here&#8217;s a more plausible example, which we actually had to deal with in practice.</p>
</div>
<div class="paragraph">
<p>In the integration of the Wizkit team&#8217;s <a href="https://dl.acm.org/doi/pdf/10.1145/3372297.3417893">Ligero ZK</a> backend with the IR, we used a resizeable array data structure to track wire numbering in a single pass, with the assumption that the all used wires would eventually be "close enough" to consecutive that it would work out to be most efficient.
Looking at all of our test cases, this seemed like a safe assumption.
However, we later decided that since the backend couldn&#8217;t do much with a switch statement, we would convert all switches to multiplexer circuits (as suggested in Section 6.3 of the <a href="https://github.com/sieve-zk/ir/raw/main/v1.0.1/sieve-ir-v1.0.1.pdf">IR specification</a>) before feeding the IR into this backend.</p>
</div>
<div class="paragraph">
<p>In our own testing the assumption of "nearly consecutive numbering starting near zero" broke down.
This is because the IR specification reserves high-order wire numbers (between 2<sup>63</sup> and 2<sup>64</sup>-1) for IR transformations&#8201;&#8212;&#8201;such as the multiplexer we chose.
When combining our multiplexer transformation with the Ligero ZK backend, our system attempted to resize the array to more than 2<sup>63</sup> elements, more space than most virtual memory systems can practically address (even in 64-bit processors).
To illustrate:</p>
</div>
<details>
<summary class="title">Here is a small example switch-case statement &#8230;&#8203;</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>@begin
  $0 &lt;- @short_witness;
  $1 &lt;- @instance;
  $2 &lt;- @short_witness;
  $3 &lt;- @instance;
  $4 &lt;- @short_witness;

  $5 &lt;- @switch($4)
    @case &lt; 0 &gt;: @anon_call($0...$3, @instance: 0, @short_witness: 0)
      $5 &lt;- @add($1, $2);
      $6 &lt;- @add($3, $4);
      $0 &lt;- @add($5, $6);
    @end
    @case &lt; 1 &gt;: @anon_call($0...$3, @instance: 0, @short_witness: 0)
      $5 &lt;- @mul($1, $2);
      $6 &lt;- @mul($3, $4);
      $0 &lt;- @mul($5, $6);
    @end
  @end
  @assert_zero($5);
@end</pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">and its automated conversion to a multiplexer.</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>@begin
  @function(wtk::mux::check_case, @out:1,@in:2,@instance:0,@short_witness:0)
    $3&lt;-@add($1,$2);
    $4&lt;-@mul($3,$3);
    $5&lt;-@mul($4,$3);
    $6&lt;-@mul($5,$5);
    $7&lt;-@mul($6,$6);
    $8&lt;-@mul($7,$7);
    $9&lt;-@mul($8,$8);
    $10&lt;-@mul($9,$9);
    $11&lt;-@mulc($10,&lt;96&gt;);
    $0&lt;-@addc($11,&lt;1&gt;);
  @end
  $0&lt;-@short_witness;
  $1&lt;-@instance;
  $2&lt;-@short_witness;
  $3&lt;-@instance;
  $4&lt;-@short_witness;
  $9223372036854775808&lt;-&lt;0&gt;;
  $9223372036854775809&lt;-&lt;96&gt;;
  $9223372036854775810...$9223372036854775811&lt;-@for wtk::mux::i @first 0 @last 1
    $(9223372036854775810 + wtk::mux::i)&lt;-@call(wtk::mux::check_case,$(9223372036854775808 + wtk::mux::i),$4);
  @end
  // original case &lt; 0 &gt;
  $9223372036854775812&lt;-@anon_call($0...$3,$9223372036854775810,@instance:0,@short_witness:0)
    $6&lt;-@add($1,$2);
    $7&lt;-@add($3,$4);
    $0&lt;-@add($6,$7);
  @end
  // original case &lt; 1 &gt;
  $9223372036854775813&lt;-@anon_call($0...$3,$9223372036854775811,@instance:0,@short_witness:0)
    $6&lt;-@mul($1,$2);
    $7&lt;-@mul($3,$4);
    $0&lt;-@mul($6,$7);
  @end
  $9223372036854775814&lt;-@add($9223372036854775810,$9223372036854775811);
  $9223372036854775815&lt;-@addc($9223372036854775814,&lt;96&gt;);
  @assert_zero($9223372036854775815);
  $9223372036854775816&lt;-@mul($9223372036854775812,$9223372036854775810);
  $9223372036854775817&lt;-@mul($9223372036854775813,$9223372036854775811);
  $5&lt;-@add($9223372036854775816,$9223372036854775817);
  @assert_zero($5);
@end</pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>At the time, our "quick solution" was for the multiplex converter to begin the high-order numbering from a much smaller constant (say 10<sup>5</sup>).
This worked out alright because the testing circuits grew in iterations of a switch rather than the size of each case.</p>
</div>
<div class="paragraph">
<p>Another solution that we considered was to split into two resizeable arrays&#8201;&#8212;&#8201;one to be zero-indexed and another to be 2<sup>63</sup>-indexed.
This approach would handle this particular split, but not all conceivable splits.
Coming from another direction, the IR specification uses a <code>Map</code> datatype, which does cover all conceivable splits at a significant performance overhead.</p>
</div>
<div class="paragraph">
<p>The final solution which we came to was a table of heuristically sized ranges (a "lookup table").
The ranges are ordered for binary search, then a particular wire within the range may be array-indexed.
This comes with the drawback of high code complexity, as range overlaps must be avoided.
However, compared to <code>std::unordered_map</code>, this comes with about a 1.4x speedup for IR-Simple, and we&#8217;ve measured up to a 6x speedup when using IR loops.</p>
</div>
<div class="paragraph">
<p>While we can take pride in overcoming issues with large-discontinuities, we would prefer to avoid this entirely.
Changes to the IR could enable TA1 to encode prior knowledge of an ideal memory layout for TA2 to pick up.</p>
</div>
</div>
<div class="sect2">
<h3 id="consecutive-discontiguities">Consecutive Discontiguities</h3>
<div class="paragraph">
<p>"Consecutive Discontiguities" are a strange phenomenon we&#8217;ve seen in testing the IR where consecutively numbered wires exist in discontiguous, or non-adjacent, memory locations.
They tend to arise mainly in remapping wires from an outer scope to an inner or function scope:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When elements of an invocation&#8217;s input or output list are non-consecutive or are themselves consecutive discontiguities.</p>
</li>
<li>
<p>At the boundary between the output and input range.</p>
</li>
<li>
<p>At the boundary between the input and local range.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example function (an arithmetic multiplexer, to be specific).</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@function(a_mux,
    @out: 1, @in: 8, /* ... */)
  // $0: output
  // $1 ... $4: data input wires
  // $5 ... $8: selector input wires
  $9 &lt;- @mul($1, $5);
  $10 ... $12 &lt;- @for i @first 2 @last 4
    $(9+i) &lt;- @anon_call(
         $i, $(5+i), $(8+i), /* ... */)
      $4 &lt;- @mul($1, $2);
      $0 &lt;- @add($3, $4);
    @end
  @end
  $0 &lt;- $12;
@end</pre>
</div>
</div>
<div class="paragraph">
<p>In its first invocation, all remaps are contiguous, so the only discontiguity is between the input and local ranges.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/* Assume $4 ... $11 are assigned */
$3 &lt;- @call(a_mux, $4 ... $11);</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/retrospective/lookup_table_desired.png" alt="lookup table desired">
</div>
<div class="title">Figure 1. The first invocation&#8217;s lookup table has a single range for each of the outputs, inputs, and local wires.</div>
</div>
<div class="paragraph">
<p>In the second invocation, there are consecutive discontiguities within and around the input and output ranges.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/* Assume $0 ... $20 are assigned */
$22 &lt;- @call(a_mux, $0 ... $2, $9, $5 ... $6, $15, $20)</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/retrospective/lookup_table_discontiguities.png" alt="lookup table discontiguities">
</div>
<div class="title">Figure 2. The second invocation&#8217;s lookup-table has many ranges remapped from the outer scope, in addition to the local wires.</div>
</div>
<div class="paragraph">
<p>The net effect is that more time is spent remapping small ranges into the lookup table, and that there is a lot of pollution in the table.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="what-else-is-missing">What Else is Missing?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to the deficiencies in the wire-numbering system, we believe the following somewhat obvious features should be added to the IR.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Size-Parameterized Function Gates</dt>
<dd>
<p>At the moment a function gate must have a fixed number of input and output wires.
As a simple example, consider a function gate that sums all its input wires.
To sum 4 wires, 5 wires, or 6 wires one would need different function gates, even though it seems like an obvious enough task for a single function gate to handle.</p>
</dd>
<dt class="hdlist1">Switch Default Case</dt>
<dd>
<p>The IR does not allow for programmable behavior if no case is matched within a switch statement.
Switches are the only element of the IR that allow for input-dependent control flow; loops and function gates have fixed size, and recursion is strictly forbidden.
It makes sense that they be as flexible as possible.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusions">Conclusions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In an early iteration of this article, the conclusion was that many of the criticisms I came up with would be moot if we implemented a two-pass interpreter for the IR.
Memory boundaries could then be reconstructed and used to improve performance.
Well, as I finish writing this update, said two-pass interpreter, BOLT, is partially implemented, and it will be the subject of a later article.
However, in developing BOLT, it became apparent that just having bounds was not the end of the story.
Most notably in processing loops, there was no enforcement of the meager bounds that had been reconstructed in the first pass.</p>
</div>
<div class="paragraph">
<p>Another to-be-written article will discuss what changes Wizkit would like to make in the next IR iteration.
Much of the emphasis of the proposed changes will be on making memory boundaries clear to the IR.
I think another worthy goal, in the realm of balancing performance and complexity, would be for single-pass interpreters of the next IR to be competitive with multi-pass interpreters for this iteration.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><category term="Retrospective" /><summary type="html"><![CDATA[In our previous post we took a first look at the SIEVE IR, presenting it as impartially as possible. Today we will take a more "opinionated" or normative look at the IR. On the one hand, we are very proud of this accomplishment&#8201;&#8212;&#8201;(to our knowledge) the first widely implemented circuit representation for ZK. However, we&#8217;d also like to acknowledge that the IR has its flaws and highlight where we think there is room for improvement.]]></summary></entry><entry><title type="html">Introducing the SIEVE Intermediate Representation</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2021/09/20/introducing-the-sieve-ir.html" rel="alternate" type="text/html" title="Introducing the SIEVE Intermediate Representation" /><published>2021-09-20T00:00:00-04:00</published><updated>2021-09-20T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2021/09/20/introducing-the-sieve-ir</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2021/09/20/introducing-the-sieve-ir.html"><![CDATA[<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#background">Background</a></li>
<li><a href="#early-ir-development">Early IR Development</a></li>
<li><a href="#a-streaming-modification">A "Streaming" Modification</a></li>
<li><a href="#structuring-the-ir">Structuring the IR</a>
<ul class="sectlevel2">
<li><a href="#function-gates">Function Gates</a></li>
<li><a href="#switch-case-statements">Switch Case Statements</a></li>
<li><a href="#for-loops">For Loops</a></li>
</ul>
</li>
<li><a href="#example-twos-complement-calculator">Example: Two&#8217;s Complement Calculator</a></li>
<li><a href="#concluding-thoughts">Concluding thoughts</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Recently the <a href="https://www.darpa.mil/program/securing-information-for-encrypted-verification-and-evaluation">DARPA SIEVE Program</a> released a 1.0.1 version of its primary program-wide deliverable, the <a href="https://github.com/sieve-zk/ir">SIEVE Intermediate Representation (IR)</a>.
As one of the primary developers of the IR, team Wizkit will write a series of posts about the IR, what it got right, what it got wrong, and what we&#8217;d like to see in upcoming versions.
But today we will start the series with this post as more of an impartial introduction to the SIEVE IR.
It is our hope that this will ease you into using the SIEVE IR in your own work, and (most importantly) enable you to read further posts in this series.</p>
</div>
<div class="paragraph">
<p>In writing this, we assume the reader has a cursory understanding of Zero-Knowledge Proofs (ZK).
If you know who the "prover" and "verifier" are, and know what a "relation", "instance", and "witness" are, then you should be okay.
An understanding of finite-field arithmetic in GF(<em>p</em>) and boolean arithmetic (equivalently, arithmetic in GF(2)) would also be helpful.</p>
</div>
<div class="paragraph">
<p>To be just a bit more precise, we&#8217;re working in the following setting:  There are two parties, a "Prover" and a "Verifier".  The Prover wants to prove some statement to the Verifier "in zero knowledge"&#8201;&#8212;&#8201;that is, informally, without allowing the Verifier to learn anything other than that the statement is true.  As usual (and necessary) in the world of ZK, we assume that the statement to be proven amounts to a decision problem in the complexity class NP.  As such, the statement can be formulated as "<em>R</em>(<em>x</em>,<em>w</em>)", where <em>x</em> is some public "instance" known to both the Prover and the Verifier, <em>w</em> is a secret "witness" known only to the Prover, and <em>R</em> is a public boolean NP relation (or, equivalently, a witness relation for some NP language <em>L</em>).  The statement to be proven can be thought of as a statement "about" the instance <em>x</em> whose validity is "witnessed" by the witness <em>w</em>.</p>
</div>
<div class="paragraph">
<p>Finally, it should be noted that the IR has two syntaxes: text and binary.
In this post, we will describe the IR by reference to the text format.
To learn more about the binary format see <a href="https://github.com/sieve-zk/ir/raw/main/v1.0.1/sieve-ir-v1.0.1.pdf">section 5 of the IR spec</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="background">Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the mandates of the SIEVE Program is for performers to come up with a common Intermediate Representation, or "IR."
The IR is a simplistic programming language for representing the NP statements to prove in ZK.
It must be simple enough for ZK proof systems (which we will from here on out refer to as "ZK backends") to prove efficiently, but expressive enough as to not limit the frontend programming language that produces the statement.
The SIEVE IR (we will use this interchangeably with just "IR" from now on) represents NP statements using boolean or arithmetic circuits with values contained in "wires".
The reader should recall that boolean and arithmetic circuit satisfiability are NP-complete problems, and so any NP relation has such a representation.
We use the terminology "short witness" to refer to the prover&#8217;s secret inputs to the circuit.
We use the adjective "short" to contrast with a hypothetical "extended" witness which would consist of the values of <em>every</em> wire in a satisfying assignment of the circuit.
Boolean circuits have 0 or 1 values and logical <code>AND</code>, <code>XOR</code>, and <code>NOT</code> gates.
Arithmetic circuits have <a href="https://en.wikipedia.org/wiki/Finite_field">field element</a> values with addition and multiplication gates.
The IR currently supports only fields GF(<em>p</em>) of prime field size <em>p</em>, that is, the integers modulo the prime <em>p</em>.</p>
</div>
<div class="paragraph">
<p>At the beginning of the program, we debated the merits of different levels of expressivity, but settled on a very simple "list-of-gates" IR, with the understanding that we would build upwards from this.
The stated goal of this early IR (which we colloquially refer to as "IR0") had feature parity to <a href="https://homes.esat.kuleuven.be/~nsmart/MPC/">Bristol Fashion</a>, but with a spin towards ZK and an eye towards extension.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="early-ir-development">Early IR Development</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Each wire of a circuit in IR0 was represented as an index to a global array of "wires", and each gate was listed in the relation as a function of its input wires assigned to its output wire.
The first 0 through <code>n</code> wires were assigned by the instance and the next <code>n+1</code> through <code>n+m</code> were assigned by the short witness (for some appropriate <code>n</code> and <code>m</code>, of course).</p>
</div>
<div class="paragraph">
<p>IR0 also had a short header listing certain aspects of the circuit:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An IR version number</p>
</li>
<li>
<p>Whether to use arithmetic or boolean gates</p>
</li>
<li>
<p>A field description, consisting of</p>
<div class="ulist">
<ul>
<li>
<p>the characteristic <em>p</em> (for GF(<em>p</em>))</p>
</li>
<li>
<p>a vestigial degree <em>n</em> (for GF(<em>p<sup>n</sup></em>)); however, this degree is currently fixed at 1, as we decided not to handle extension fields until a later phase.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The total number of wires in the circuit (including instance and short witness wires)</p>
</li>
<li>
<p>The number of instance wires</p>
</li>
<li>
<p>The number of short witness wires</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, IR0 existed as a combination of three "resources" (files).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Instance resource listed assignments of values to wires 0 through <code>n</code>.</p>
</li>
<li>
<p>The Short Witness resource assigns values to wires <code>n+1</code> through <code>n+m</code>.</p>
</li>
<li>
<p>The Relation lists gates for assignments of the remaining wires in the circuit.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each wire was assigned exactly once and had to be assigned a value before being used as a subsequent gate&#8217;s input.
In other words, wires adhered to the following requirements: <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">"Single Static Assignment" (SSA)</a> and topological ordering.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-streaming-modification">A "Streaming" Modification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Soon after this, we made modifications that enabled "streaming" proof systems in cases where the entirety of an NP statement may not be available at the beginning of the proof computation, or loading the entirety of it may exceed available memory.
This is similar to piping <code>awk</code>, <code>grep</code>, and <code>sed</code> together for regular text manipulations.</p>
</div>
<div class="paragraph">
<p>To support such an operating paradigm, we made three changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Did away with the circuit size declarations.</p>
</li>
<li>
<p>Changed the instance and short witness to streams of values, rather than lists of assignments, where assignments are handled by "special" <code>@instance</code> and <code>@short_witness</code> directives in the relation.
Each of these directives behaves like <code>C</code>'s <code>fgetc(stream)</code> for its stream, returning the next value, and advancing the stream by one.</p>
</li>
<li>
<p>Added a special "delete" gate to indicate that certain wires are no longer needed and associated memory could be freed.
Delete may be used with a single argument or with a first and last argument to indicate a range of wires.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This core IR is still present, although newer features have necessitated additional changes to the IR header.
Here is an example of an NP statement encoded in what is now referred to as "IR-Simple".
Given two legs (as their lengths), this example proves the existence of a right triangle with those legs using Pythagoras&#8217;s theorem.</p>
</div>
<div class="listingblock">
<div class="title">Relation</div>
<div class="content">
<pre>version 1.0.1;        // The latest IR version
field                 // GF(p) as defined by
  characteristic 127  // this prime number p
  degree 1;           // and a vestigial degree (always 1)

relation              // indicates that this resource is a relation
gate_set: arithmetic; // Will use add/mul/addc/mulc instead of xor/and/not
features: simple;     // Only features of this "simple"/"streaming" IR are used
@begin                // The body of the relation
  $0 &lt;- @instance;        // leg A
  $3 &lt;- @mul($0, $0);     // A^2
  $1 &lt;- @instance;        // leg B
  $4 &lt;- @mul($1, $1);     // B^2
  $2 &lt;- @short_witness;   // hypotenuse C
  $5 &lt;- @mul($2, $2);     // C^2
  @delete($0, $2);        // We have the squares, so we don't need A, B, and C
  $6 &lt;- @add($3, $4);     // A^2 + B^2
  // We want to prove that A^2 + B^2 == C^2, but we can't do equality directly
  // Instead show that A^2 + B^2 - C^2 == 0.
  $7 &lt;- @mulc($5, &lt;126&gt;); // Negate C^2 by multiplying by p-1
  $8 &lt;- @add($6, $7);     // add it all up,
  @assert_zero($8);       // and prove it is zero.
@end</pre>
</div>
</div>
<div class="paragraph">
<p>For the more visually oriented, the circuit would look like this.
Also, if you don&#8217;t mind us tooting our own horns, check out our <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/tools/wtk-viz.html">wiztoolkit visualization tool</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/wizkit-blog/attachments/ir1-intro/triangle.svg" alt="A graphical visualization of the prior triangle circuit. Each gate is a circle with its calculation and assignment" width="and each wire is an arrow connecting its assignment to its usage as an input wire"></span></p>
</div>
<div class="paragraph">
<p>The instance and witness would appear as the following for a "3 4 5" triangle.</p>
</div>
<div class="listingblock">
<div class="title">Instance</div>
<div class="content">
<pre>version 1.0.1;
field characteristic 127 degree 1;
instance @begin
  &lt;3&gt;; // leg A
  &lt;4&gt;; // leg B
@end</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Short Witness</div>
<div class="content">
<pre>version 1.0.1;
field characteristic 127 degree 1;
short_witness @begin
  &lt;5&gt;; // hypotenuse C
@end</pre>
</div>
</div>
<div id="executing-with-firealarm" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Executing the IR with FIREALARM</div>
<div class="paragraph">
<p>To run the IR absent of ZK&#8201;&#8212;&#8201;that is, to simply evaluate an circuit with inputs from an instance and short witness "in the clear," rather than proving satisfiability in zero knowledge&#8201;&#8212;&#8201;for development, debugging, and education purposes, Stealth has developed the <code>wtk-firealarm</code> tool as part of our <a href="https://stealthsoftwareinc.github.io/wiztoolkit/">WizToolKit library</a> (<a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/install.html">installation instructions</a>).
<code>wtk-firealarm</code> has a one-argument mode for checking that an IR resource is well formed and a three-argument mode for checking that an IR witnessed statement is well formed, i.e., that the instance and short witness do in fact satisfy the relation.</p>
</div>
<div class="paragraph">
<p><code>wtk-firealarm</code> recognizes each IR resource by the following file suffixes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>.rel</code> for the relation.</p>
</li>
<li>
<p><code>.ins</code> for the instance.</p>
</li>
<li>
<p><code>.wit</code> for the short witness.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To give it a try, copy and paste the triangle example above into text files (with appropriate suffixes) and try invoking firealarm in both modes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; wtk-firealarm circuit.rel
&gt; wtk-firealarm circuit.rel public_inputs.ins prover_inputs.wit</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="structuring-the-ir">Structuring the IR</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Currently, the IR contains three features for adding program structure and control flow.
This provides simplifying abstractions away from purely unstructured circuit formats such as Bristol Fashion.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Function Gates</dt>
<dd>
<p>Encapsulate a sub-circuit for reuse elsewhere in the relation.</p>
</dd>
<dt class="hdlist1">Switch Case Statements</dt>
<dd>
<p>Conditionally branch between assignments of alternative sub-circuits.</p>
</dd>
<dt class="hdlist1">For Loops</dt>
<dd>
<p>Repeat a single sub-circuit many times.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Going into these features, understand that wires in SIEVE IR are <strong>not</strong> lexically scoped.
The bodies (sub-circuits) of each structural element are as independent of each other as possible.
Each sub-circuit defines its own wire-numbering space, each one starting back from zero.</p>
</div>
<div class="paragraph">
<p>It is worth reiterating that each sub-circuit&#8217;s numbering space must maintain the SSA and topological ordering principles described earlier.</p>
</div>
<div class="sect2">
<h3 id="function-gates">Function Gates</h3>
<div class="paragraph">
<p>Superficially, a function gate declares a sub-circuit.
The sub-circuit can be "invoked" elsewhere, connecting wires from the caller to those of the function.
An important consequence of this is that the internals of the function gate are isolated from the caller and locally scoped within the function.
Because of this "connected isolation", the function gate is a building block for the other two features.</p>
</div>
<div class="paragraph">
<p>A function gate is declared at the top of a relation.
Its declaration adds nothing to the relation until it is invoked later.
It has 5 identifying characteristics.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Name</p>
</li>
<li>
<p>Number of Output wires</p>
</li>
<li>
<p>Number of Input wires</p>
</li>
<li>
<p>Number of Instance Consumptions</p>
</li>
<li>
<p>Number of Short Witness Consumptions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first three allow the sub-circuit to be referenced and connected into another circuit.
The latter two define the side-effects to be expected after the circuit&#8217;s invocation, which will become important for switch cases.</p>
</div>
<div class="paragraph">
<p>A mapping is used to connect wires from the calling scope into and out of the function&#8217;s scope.
In the function&#8217;s scope, output wires are numbered sequentially from 0 through <em>number of outputs</em> - 1, and inputs from <em>number of outputs</em> through <em>number of outputs</em> + <em>number of inputs</em> - 1.
At invocation, arguments are bound positionally.
The caller lists each output and then each input, and in that order they are bound to <code>$0</code>, <code>$1</code>, <code>$2</code>&#8230;&#8203; in the callee&#8217;s scope.
Here is an example that squares the last input, then sums it with the first three input wire values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@function(add4_sq_last, @out: 1, @in: 4, @instance: 0, @short_witness: 0)
  // $0: single output wire
  // $1, $2, $3, $4: input wires
  // $5 and onwards: local wires
  $5 &lt;- @add($1, $2);
  $6 &lt;- @mul($4, $4);
  $7 &lt;- @add($3, $6);
  $0 &lt;- @add($5, $7);
@end

// output assigns to $10, inputs are connected to $6, $7, $2, and $3
// $3 got squared
$10 &lt;- @call(add4_sq_last, $6, $7, $2, $3);
// now $7 got squared
$11 &lt;- @call(add4_sq_last, $2, $3, $6, $7);

// Sequential wires may be abbreviated to a range
$12 &lt;- @call(add4_sq_last, $2 ... $5);
// And ranges may be mixed with single elements in a list
$13 &lt;- @call(add4_sq_last, $2 ... $4, $6);</pre>
</div>
</div>
<div class="paragraph">
<p>An anonymous function invocation syntax is also available.
This exists mainly to allow the appearance of nested loops and switch statements.
Here is the same function body, now invoked as an inline function.
Obviously, it doesn&#8217;t need a function name, but also the input and output wire counts are inferred.
The example below illustrates this inference.
The instance and short witness counts must still be declared in the anonymous function signature.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$14 &lt;- @anon_call($10 ... $13, @instance: 0, @short_witness: 0)
  // Caller-scoped wires $10 ... $13 are mapped to locally scoped wires $1 ... $4.
  // Caller-scoped wire $14 is mapped to locally scoped wire $0.
  // Wires &gt;= $5 are locally scoped.
  $5 &lt;- @add($1, $2);
  $6 &lt;- @mul($4, $4);
  $7 &lt;- @add($3, $6);
  $0 &lt;- @add($5, $7);
@end</pre>
</div>
</div>
<div class="paragraph">
<p>One last thing to note is that recursive function gates are prohibited.
This is because a function gate is not a function; it emulates a circuit, not a processor, and thus there is no actual call stack.</p>
</div>
</div>
<div class="sect2">
<h3 id="switch-case-statements">Switch Case Statements</h3>
<div class="paragraph">
<p>Switch statements allow a circuit to assign wires as the <em>results of a conditional branch</em>.
Here is an example switch statement which either sums or multiplies some inputs. Neither case in this example has side effects.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// The following switch statement chooses between output wire $0 from each case. The case is selected based on the value of $4.
$5 &lt;- @switch($4)
  @case &lt; 0 &gt;: @anon_call($0...$3, @instance: 0, @short_witness: 0)
    // Calling scope $5 corresponds to local scope $0
    // Calling scope $0 ... $3 corresponds to local scope $1 ... $4
    // $5 and $6 are local
    $5 &lt;- @add($1, $2);
    $6 &lt;- @add($3, $4);
    $0 &lt;- @add($5, $6);
  @end
  @case &lt; 1 &gt;: @anon_call($0...$3, @instance: 0, @short_witness: 0)
    // Same scoping as above case.
    $5 &lt;- @mul($1, $2);
    $6 &lt;- @mul($3, $4);
    $0 &lt;- @mul($5, $6);
  @end
@end</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that, as with the for loops described below, the body of each case is a function gate.
Each case&#8217;s function gate is missing its output wire list; instead, all cases share the output list of the entire switch.
In the above example, cases share output wire $5 at the very top, which is a wire list of length one.</p>
</div>
<div class="paragraph">
<p>In standard programming languages we are accustomed to conditional features skipping the evaluation of not-taken branches.
This is not the case in the IR.
Remember that one of our goals&#8201;&#8212;&#8201;in fact, the essence of ZK&#8201;&#8212;&#8201;is to reveal no more than just the statement&#8217;s validity; if two branches vary in length, then short-evaluating branches may leak some of the witness.
Generally, this means that ZK backends must evaluate all branches, although some schemes can amortize this to the length of the longest branch.</p>
</div>
<div class="paragraph">
<p>Obviously evaluating all branches is not ideal because side effects in non-selected branches could cause program failures and unexpected behavior.
To reduce the burden on ZK frontends to keep track of such side effects (e.g., advancing streams, and causing proof failures), the IR semantics disable them in non-selected branches.
If the IR did not alleviate this burden, then ZK frontends would need to account for the side effects of non-taken branches and manually undo them in their relations.</p>
</div>
<div class="paragraph">
<p>Most IR directives (<code>@and</code>, <code>@xor</code>, <code>@mul</code>, etc, and even <code>@call</code>, etc.) don&#8217;t have side effects and have unchanged behavior within a non-selected branch.
However, three directives will cause side-effects which last beyond a branch.
The <code>@assert_zero</code> directive is the simplest effect to "cancel".
All it does is cause the prover to conditionally reject a proof, so it&#8217;s possible to change the condition such that it is always acceptable to the verifier by multiplying its input wire by either 0 or 1.</p>
</div>
<div class="paragraph">
<p>The <code>@instance</code> and <code>@short_witness</code> directives each consume a value from the instance or short witness (collectively input) streams.
This effect is harder to cancel, because if each case consumes a different number of values, different evaluations would need differently sized input streams.
Requiring differently sized streams reveals which case was taken, so this solution was rejected.
The next solution was to require inputs to contain sufficiently many values that the sum of all cases' input consumptions can be used, but this padding may require many extra values and is quite non-intuitive.
The solution we accepted is to require the switch to consume the maximum consumption of all cases, and repeat input values in each case.
In unselected cases, this means it likely processes garbage values, but the affects of any garbage would be disabled by the switch.</p>
</div>
<div class="paragraph">
<p>Here is an example of this in action, where we assume the instance and the short witness each assign three wire values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@switch($0)
  @case &lt; 0 &gt;: @anon_call(@instance: 3, @short_witness: 1)
    $1 &lt;- @instance;
    $2 &lt;- @instance;
    $3 &lt;- @instance;
    $4 &lt;- @short_witness;
    $5 &lt;- @add($1, $2);
    $6 &lt;- @add($3, $4);
    $0 &lt;- @add($5, $6);
    @assert_zero($0);
  @end
    @case &lt; 1 &gt;: @anon_call(@instance: 1, @short_witness: 3)
    $1 &lt;- @instance;
    $2 &lt;- @short_witness;
    $3 &lt;- @short_witness;
    $4 &lt;- @short_witness;
    $5 &lt;- @mul($1, $2);
    $6 &lt;- @mul($3, $4);
    $0 &lt;- @mul($5, $6);
    @assert_zero($0);
  @end
@end</pre>
</div>
</div>
<div class="paragraph">
<p>If the first case is taken, all instance values are "used", only one short witness value is "used", and the remaining short witness values are "discarded".
If the second case is taken only one instance value is "used", all three short witness values are "used", and the remaining instance values are "discarded".
However, in both cases the switch always consumes three instance values and three short witness values.</p>
</div>
<div class="paragraph">
<p>In the first case, it then asserts that the inputs <em>sum</em> to zero, while the second checks that the <em>product</em> of a different set of inputs is zero.
Assuming only one of these statements is true (and that the true one is the active branch), the <code>@assert_zero</code> in the non-active branch gets "disabled" by the ZK backend, for example, by multiplying by zero.
The "active" <code>@assert_zero</code> must similarly be "enabled", by multiplying by one.</p>
</div>
</div>
<div class="sect2">
<h3 id="for-loops">For Loops</h3>
<div class="paragraph">
<p>Now that we&#8217;ve understood function gates, a for loop is defined by a repetition of a function gate as its body over a prescribed range of repetitions.
Here is an example that outputs the first 10 Fibonacci numbers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$0 &lt;- &lt;1&gt;;
$1 &lt;- &lt;1&gt;;

$2 ... $10 &lt;- @for i @first 2 @last 10
  $i &lt;- @anon_call($(i - 1), $(i - 2), @instance: 0, @short_witness: 0)
    $0 &lt;- @add($1, $2);
  @end
@end</pre>
</div>
</div>
<div class="paragraph">
<p>The above is equivalent to this sequence of function calls (although I did change from an anonymous to a named function, for succinctness):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@function(add_func, @out: 1, @in: 2, @instance: 0, @short_witness: 0)
  $0 &lt;- @add($1, $2);
@end

$0 &lt;- &lt;1&gt;;
$1 &lt;- &lt;2&gt;;
$2 &lt;- @call(add_func, $0, $1);
$3 &lt;- @call(add_func, $1, $2);
$4 &lt;- @call(add_func, $2, $3);
$5 &lt;- @call(add_func, $3, $4);
$6 &lt;- @call(add_func, $4, $5);
$7 &lt;- @call(add_func, $5, $6);
$8 &lt;- @call(add_func, $6, $7);
$9 &lt;- @call(add_func, $7, $8);
$10 &lt;- @call(add_func, $8, $9);</pre>
</div>
</div>
<div class="paragraph">
<p>The loop itself assigns a list of output wires by repeating its body with an iterator (in the above example, <code>i</code>) that increments from a first to a last value.
The loop&#8217;s function gate allows a special syntax for the input and output wires (but not for wires within an anonymous function&#8217;s body, nor for the loop&#8217;s bounds and consumptions).
Namely, wire indices may be replaced by multiples and offsets of the loop&#8217;s iterator.
If this were not the case, then the function would uselessly repeat the same calculation and illegally reassign the same output wire.</p>
</div>
<div class="paragraph">
<p>The "iterator expression" syntax (for example, the input and output lists of the above for loop&#8217;s function) is used to express multiples and offsets of the iterator.
It may be composed of numeric constants and any in-scope loop iterators.
Allowed operations are addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>) and division only by a constant (<code>/</code>).
There is no operator precedence, and all sub-expressions must be parenthesized.
For example, instead of writing <code>$(48 + i - j * 5)</code> you must use <code>$(48 + (i - (j * 5)))</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Although wires use "remap" scoping where they must be passed as function-gate arguments, loop iterators follow lexical scoping rules.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="example-twos-complement-calculator">Example: Two&#8217;s Complement Calculator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here&#8217;s an example that encapsulates what we&#8217;ve covered in this post.
See the inline comments for explanation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>version 1.0.0;
field characteristic 2 degree 1;
relation
gate_set: boolean;
features: @function, @for, @switch;
@begin
  @function(bit_adder, @out: 2, @in: 3, @instance: 0, @short_witness: 0)
    // $0 is sum
    // $1 is carry out
    // $2 is a
    // $3 is b
    // $4 is carry out

    // This is a 1-bit adder.
    $5 &lt;- @xor($2, $3);
    $6 &lt;- @xor($2, $4);
    $7 &lt;- @and($5, $6);
    $1 &lt;- @xor($7, $2);
    $0 &lt;- @xor($5, $4);
  @end

  // Lets fill the calculator ins/outs as follows
  // $0 ... $31 will be the sum, Least-Significant-Bit (LSB) first, sign last

  // $32 ... $63 input A, LSB-first, sign-last
  $32 ... $63 &lt;- @for i @first 0 @last 31
    $(32 + i) &lt;- @anon_call(@instance: 0, @short_witness: 1)
      $0 &lt;- @short_witness;
    @end
  @end

  // $64 ... $95 input B, LSB-first, sign-last
  $64 ... $95 &lt;- @for i @first 0 @last 31
    $(64 + i) &lt;- @anon_call(@instance: 0, @short_witness: 1)
      $0 &lt;- @short_witness;
    @end
  @end

  // $96 operation, 0 for add or 1 for subtract.
  $96 &lt;- @short_witness;

  // $97 ... $28 are the adjusted input B
  $97 ... $128 &lt;- @switch($96)
    @case &lt;0&gt;: @anon_call($64 ... $95, @instance: 0, @short_witness: 0)
      // addition, don't adjust.
      // $0 ... is the case's output mapping
      // $32 ... is the case's input mapping
      $0 ... $31 &lt;- @for i @first 0 @last 31
        $i &lt;- @anon_call($(i + 32), @instance: 0, @short_witness: 0)
          $0 &lt;- $1;
        @end
      @end
    @end
    @case &lt;1&gt;: @anon_call($64 ... $95, @instance: 0, @short_witness: 0)
     // subtraction, adjust by negating bits.
      // $0 ... is the case's output mapping
      // $32 ... is the case's input mapping
      $0 ... $31 &lt;- @for i @first 0 @last 31
        $i &lt;- @anon_call($(i + 32), @instance: 0, @short_witness: 0)
          // don't adjust for addition.
          $0 &lt;- @not($1);
        @end
      @end
    @end
  @end

  // Lets add it up now.
  // $129 ... $160 can be carry bits.

  // Carry in the operation (0=add, 1=sub) to finish the compliment.
  $0, $129 &lt;- @call(bit_adder, $32, $97, $96);

  $1 ... $31, $130 ... $160 &lt;- @for i @first 1 @last 31
    $i, $(129 + i) &lt;- @call(bit_adder, $(32 + i), $(97 + i), $(128 + i));
  @end

  // clean up the extra wires for adjusting and carry bits.
  @delete($97, $128);
  @delete($129, $159);

  // And finally lets just assert that there was no overflow.
  // (invert the overflow bit during subtraction)
  $161 &lt;- @xor($160, $96);
  @assert_zero($161);

  // And assert that the sum is as expected by the instance.
  @for i @first 0 @last 31
    @anon_call($i, @instance: 1, @short_witness: 0)
      // $0: bit in sum
      $1 &lt;- @instance;
      $2 &lt;- @xor($0, $1);
      @assert_zero($2);
    @end
  @end
@end</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concluding-thoughts">Concluding thoughts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We hope this introduction has given our readers an insight into the thought process and the mechanics of the SIEVE IR&#8217;s most recent revision.
In upcoming posts we will take a look at some of what we like and dislike about this revision of the IR, to be concluded with our goals for and some of the mechanics we would like to see in the next revision.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><summary type="html"><![CDATA[Recently the DARPA SIEVE Program released a 1.0.1 version of its primary program-wide deliverable, the SIEVE Intermediate Representation (IR). As one of the primary developers of the IR, team Wizkit will write a series of posts about the IR, what it got right, what it got wrong, and what we&#8217;d like to see in upcoming versions. But today we will start the series with this post as more of an impartial introduction to the SIEVE IR. It is our hope that this will ease you into using the SIEVE IR in your own work, and (most importantly) enable you to read further posts in this series.]]></summary></entry></feed>