<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://stealthsoftwareinc.github.io/wizkit-blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://stealthsoftwareinc.github.io/wizkit-blog/" rel="alternate" type="text/html" /><updated>2023-08-30T16:01:39-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/feed.xml</id><title type="html">Team Wizkit</title><entry><title type="html">Introducing the SIEVE Circuit-IR: Retrospective</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/13/sieve-circuit-ir-retrospective.html" rel="alternate" type="text/html" title="Introducing the SIEVE Circuit-IR: Retrospective" /><published>2023-07-13T00:00:00-04:00</published><updated>2023-07-13T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/13/sieve-circuit-ir-retrospective</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/13/sieve-circuit-ir-retrospective.html"><![CDATA[<div class="paragraph">
<p>In prior posts to this blog, we&#8217;ve certainly aired our grievances with the prior IR release (v1, whereas we&#8217;re now at v2).
You may want to go back and skim <a href="2021-11-01-sieve-ir-v1.0-retrospective.adoc">the previous retrospective</a> and our <a href="2021-11-19-BOLT-two-pass-interpreter.adoc">BOLT fast interpreter</a>.
But if you don&#8217;t want to review those, IR1&#8217;s (IR1 was the old IR&#8217;s code name) memory layout was completely disorganized, and some of its higher level features proved difficult (<code>@switch</code>) or slow (<code>@for</code>) to implement.
We spent a bit of time developing the BOLT interpreter with a few tricks for greatly accelerating how loops could be processed.</p>
</div>
<div class="paragraph">
<p>Previously, our team came up with a plan for a two layered approach to the IR (<a href="2022-05-26-replacing-the-sieve-ir.adoc">plan</a> and <a href="2022-09-26-evolving-the-sieve-ir-our-concrete-proposal.adoc">proposal</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a low level to approximate a largely flat circuit</p>
</li>
<li>
<p>a layer with higher level control flow, translatable to both the lower layer and to other high level representations (such as our <a href="https://github.com/emp-toolkit/emp-zk">EMP-ZK&#8217;s C++</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The intention of the multi layer approach was that translating a high level IR to a flat circuit would enable flexibility and backwards compatibility, while the high level IR could retain additional semantic information for better speed up.</p>
</div>
<div class="paragraph">
<p>So how does this new release fit into our earlier development plan?
This revision <em>is</em> a development of the aforementioned low level flat(ish) circuit, which we&#8217;re aptly calling the <strong>Circuit-IR</strong>.</p>
</div>
<div class="paragraph">
<p>The higher level "Translation-IR" is still in development, as it faced a bit of push back from other performers within the program, so we won&#8217;t discuss it in this post.</p>
</div>
<div class="paragraph">
<p>At the end of the post about BOLT, we challenged ourselves to out perform IR1 BOLT purely on improvements to the IR.
We expected that further semantic information in a higher level IR would be necessary to do this.
Instead, we managed to outperform IR1 with Circuit-IR.</p>
</div>
<div class="paragraph">
<p>We credit this performance to two developments:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Improvements to the memory layout which minimizes interpreter overhead.</p>
</li>
<li>
<p>A better balance between minimizing relation IO against interpreter overhead</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For the matrix-product circuit on a 350 sized square matrix, we see a marginal improvement from the loops/bolt column to the Circuit-IR functions column (unfortunately we see a disprovement on flat/streaming, but that&#8217;s not a column we actually care much about).
This inspired us to try generating an IR1 relation using the equivalent function structure and run it with bolt.
The result was almost twice as fast as any other column.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
These times were taken with the Non-ZK interpreters, and represent a lower bound on backend performance.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The memory usage of each also paints a story.
The memory layout of IR1 was complicated enough that we were never able to fully implement the <code>@delete</code> directive (IR1 didn&#8217;t have a <code>@new</code>).
This is very evident when comparing the flat/streaming columns.
the loops/bolt column has the lowest memory usage of all columns.
In bolt, memory use is generally proportional to the size of the Parse Tree, so the functions/bolt memory use grows a lot.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">&nbsp;</th>
<th class="tableblock halign-left valign-top">IR1 flat/streaming</th>
<th class="tableblock halign-left valign-top">IR1 loops/bolt</th>
<th class="tableblock halign-left valign-top">Circuit-IR flat/streaming</th>
<th class="tableblock halign-left valign-top">Circuit-IR functions/streaming</th>
<th class="tableblock halign-left valign-top">IR1 functions/bolt</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9G</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.4K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9G</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24M</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">time (s)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7.033s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.294s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7.838s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.051</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.867s</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">mem (k)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2111476</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12800</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20692</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">36016</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">145700</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>We are extremely pleased with the Circuit-IR.
It managed to encode enough semantic information to significantly improve upon IR1, its memory efficiency is great, and it challenged our instincts on what makes for an ideal IR.
We are strongly tempted to develop some sort of hybrid bolt/streaming interpreter for it.</p>
</div>
<hr>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
<div class="paragraph">
<p><strong>Distribution Statement "A":</strong> Approved for Public Release, Distribution Unlimited</p>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><category term="Circuit-IR" /><category term="v2.1.0" /><category term="Retrospective" /><summary type="html"><![CDATA[In prior posts to this blog, we&#8217;ve certainly aired our grievances with the prior IR release (v1, whereas we&#8217;re now at v2). You may want to go back and skim the previous retrospective and our BOLT fast interpreter. But if you don&#8217;t want to review those, IR1&#8217;s (IR1 was the old IR&#8217;s code name) memory layout was completely disorganized, and some of its higher level features proved difficult (@switch) or slow (@for) to implement. We spent a bit of time developing the BOLT interpreter with a few tricks for greatly accelerating how loops could be processed.]]></summary></entry><entry><title type="html">Introducing the SIEVE Circuit-IR: Plugins</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/11/sieve-circuit-ir-plugins.html" rel="alternate" type="text/html" title="Introducing the SIEVE Circuit-IR: Plugins" /><published>2023-07-11T00:00:00-04:00</published><updated>2023-07-11T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/11/sieve-circuit-ir-plugins</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/11/sieve-circuit-ir-plugins.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>During development of the IR, the SIEVE Program sort of decided that circuits are not expressive enough to express certain functionality.
For example, <a href="/wizkit-blog/2023/05/11/simulating-bool-in-GFp.html">the comparison and division operations</a> previously described on this blog cannot be encoded with the IR because they require plaintext computations to be performed and passed into the circuit.
Certainly the frontend could do that, but so could the backend&#8201;&#8212;&#8201;and many already can, with further tricks that a frontend can&#8217;t reliably expect to exist.
Hence, we created the plugin system to enable backends to implement certain functionalities on their own and provide an interface through the IR.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="plugin-functions">Plugin Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The IR Plugin system integrates with the IR using functions.
Any functionality of a plugin is exposed as a function gate.
The body of the function gate&#8201;&#8212;&#8201;ordinarily a list of gates&#8201;&#8212;&#8201;is replaced by by a plugin binding.
The plugin binding has the name of a plugin, and an operation within the plugin.
It may also have arbitrary additional numbers or identifiers, but most don&#8217;t.</p>
</div>
<div class="paragraph">
<p>Here is an example of the less than function, using a plugin.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// Return 1 if the first input is less than the second, otherwise return 0.
//                         output wire (bit)
//                         |         first input wire
//                         |         |    second input wire
@function(less_than, @out: 0:1, @in: 0:1, 0:1)
  @plugin(extended_arithmetic_v1, less_than);</pre>
</div>
</div>
<div class="paragraph">
<p>The plugin function is called just like an ordinary function-gate.
Here it is showing that a secret value is between two public values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$0 &lt;- @public();
$1 &lt;- @public();
$2 &lt;- @private();

$3 &lt;- @call(less_than, $1, $0);
$4 &lt;- @call(less_than, $2, $1);
$5 &lt;- @add($3, $4);
@assert_zero($5);</pre>
</div>
</div>
<div class="paragraph">
<p>Before using a plugin function, it must be declared in the circuits header&#8201;&#8212;&#8201;much like <code>#include</code>ing a function in C/C++.
The plugin include section goes between the <code>circuit</code> keyword and the first type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>version 2.1.0;
circuit;
@plugin extended_arithmetic_v1;
@type field 127;</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="plugin-types">Plugin Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some plugins need to store data between calls.
Consider the "Circuits with RAM" paradigm&#8201;&#8212;&#8201;most of the computation is a circuit, however it occasionally accesses a random offset within a storage buffer.
The RAM plugin would need to store buffers between its read and write operations.
For this, the plugin system allows for plugin types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>version 2.1.0;
circuit;
@plugin ram_arith_v1;
@type field 127;
@type @plugin(ram_arith_v1, ram, /* index/element type */ 0);</pre>
</div>
</div>
<div class="paragraph">
<p>Most plugin types must be interacted with through plugin functions.
The RAM plugin defines an <code>init</code> operation to create a new buffer, and, of course, <code>read</code> and <code>write</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// Initialize a RAM buffer. Initialize each element with the fill parameter.
//                        buffer output
//                        |         fill input
@function(ram_init, @out: 1:1, @in: 0:1)
  //                          number of elements to create
  @plugin(ram_arith_v0, init, 100);

// Read an element from a buffer
//                        element output
//                        |         buffer input
//                        |         |    index input
@function(ram_read, @out: 0:1, @in: 1:1, 0:1)
  @plugin(ram_arith_v0, read);

// Write an element into a buffer
//                        buffer input (mutated)
//                        |    index input
//                        |    |    element input
@function(ram_write, @in: 1:1, 0:1, 0:1)
  @plugin(ram_arith_v0, write);</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The SIEVE IR plugin system enables backends to provide functionality it otherwise could not, and to optimize operations beyond what a frontend could.
Check out the plugins which have been <a href="https://github.com/sieve-zk/ir/tree/main/v2.1.0/plugins">standardized by the SIEVE Program</a>, and those which are <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v2.1.0/3_plugins/0_intro.html#builtin-plugins">implemented/implementable in WizToolKit</a>.</p>
</div>
<hr>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
<div class="paragraph">
<p><strong>Distribution Statement "A":</strong> Approved for Public Release, Distribution Unlimited</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><category term="Circuit-IR" /><category term="v2.1.0" /><summary type="html"><![CDATA[During development of the IR, the SIEVE Program sort of decided that circuits are not expressive enough to express certain functionality. For example, the comparison and division operations previously described on this blog cannot be encoded with the IR because they require plaintext computations to be performed and passed into the circuit. Certainly the frontend could do that, but so could the backend&#8201;&#8212;&#8201;and many already can, with further tricks that a frontend can&#8217;t reliably expect to exist. Hence, we created the plugin system to enable backends to implement certain functionalities on their own and provide an interface through the IR.]]></summary></entry><entry><title type="html">Introducing the SIEVE Circuit-IR: Functions</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/10/sieve-circuit-ir-functions.html" rel="alternate" type="text/html" title="Introducing the SIEVE Circuit-IR: Functions" /><published>2023-07-10T00:00:00-04:00</published><updated>2023-07-10T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/10/sieve-circuit-ir-functions</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/10/sieve-circuit-ir-functions.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The SIEVE IR&#8217;s function gates will encapsulate a subcircuit so it may be reused many times over.
Doing this can drastically reduce the size of a circuit.
This may seem unimportant, considering how an interactive proof is likely to have communication proportional to the number of gates, however IO of the relation has proved to be a bottleneck in the past, and some relations have taken terabytes of space.
So, its worth it to attempt to compress the circuit as much as possible.</p>
</div>
<div class="paragraph">
<p>Another aspect of increasing the IR&#8217;s scalability is reducing memory consumption.
This installment will show off the <code>@new(/* &#8230;&#8203; <strong>/);</code> and <code>@delete(/</strong> &#8230;&#8203; */);</code> directives and show how their use impacts function gates.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="function-gates">Function Gates</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Lets start with an example: the <code>equals</code> function has two input wires and one output wire.
If the two inputs have the same value it outputs 1, otherwise it outputs 0.</p>
</div>
<div class="paragraph">
<p>A function declaration always begins with a signature listing  its output and input parameters.
Each parameter has a type index and a length.
Within the function&#8217;s body wire numbers restart at 0.
Within each type, output wires are assigned to the parameters, left to right&#8201;&#8212;&#8201;so the first output wire is 0&#8201;&#8212;&#8201;and incrementing from there.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@version 2.0.0;
circuit;
@type field 127;
@begin

  @function(equals, @out: 0:1, @in: 0:1, 0:1)
    // Output wire 0:$0
    // Input wires 0:$1 and 0:$2</pre>
</div>
</div>
<div class="paragraph">
<p>The body of the function is simply a list of gates, one of which assigns to the output wire.
For equality we&#8217;re going to use <a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem">Fermat&#8217;s Little Theorem</a> for reducing a non-zero value to 1.
When raising a number to <em>p-1</em> mod <em>p</em>, any non-zero value will yield 1.
Thus, we can subtract and exponentiate to get inequality, and flip to get equality.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    // Subtract
    $3 &lt;- @mulc($2, &lt;126&gt;);
    $4 &lt;- @add($1, $3);

    // Exponentiation by squaring, iterative method, unrolled.
    $5 &lt;- @mul($4, $4);
    $6 &lt;- @mulc($5, &lt;1&gt;);
    $7 &lt;- @mul($5, $5);
    $8 &lt;- @mul($7, $6);
    $9 &lt;- @mul($7, $7);
    $10 &lt;- @mul($9, $8);
    $11 &lt;- @mul($9, $9);
    $12 &lt;- @mul($11, $10);
    $13 &lt;- @mul($11, $11);
    $14 &lt;- @mul($13, $12);
    $15 &lt;- @mul($13, $13);
    $16 &lt;- @mul($14, $15);
    // Did I mention the IR is intended to be computer generated?

    // Flip from 0|1 to 1|0
    $17 &lt;- @mulc($16, &lt;126&gt;); // 0 or -1
    $0 &lt;- @addc($17, &lt;1&gt;); // assigns to the output wire
 @end</pre>
</div>
</div>
<div class="paragraph">
<p>Using an equality check is now as simple as calling this function.
The <code>$outputs&#8230;&#8203; &#8592; @call(function_name, $inputs&#8230;&#8203;);</code> syntax lets us do just that.
Each wire or wire range specified in the call gate will be passed to the function.
Input wires must have been previously assigned in the circuit, while output wires will be assigned by the function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  $0 &lt;- @private();
  $1 &lt;- @private();

  // call the function
  $2 &lt;- @call(equals, $0, $1);

  @assert_zero($2);
@end</pre>
</div>
</div>
<div class="paragraph">
<p>When using functions with multiple types, the call gate doesn&#8217;t actually need type indexes for each parameter, in fact the syntax does not even allow for this.
Instead, the backend can look at the function&#8217;s signature and each parameter is retrieved using the type from the signature.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a quick example.
Notice that the commented types of the <code>@call</code> match those of the function definition</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@function(foo, @out: 0:1, 1:1, @in 1:1, 0:1, 1:1)
  /* ... */
@end

$0 &lt;- @private(0);
$0 &lt;- @private(1);
$1 &lt;- @private(1);

/* 0 */ $2, /* 1 */ $2 &lt;- @call(foo, /* 1 */ $0, /* 0 */ $0, /* 1 */ $1);

@assert_zero(0: $2);
@assert_zero(1: $2);</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="memory-management">Memory Management</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Memory management in the IR began with the addition of a <code>@delete($first &#8230;&#8203; $last);</code> gate which hinted to a backend that a range of wires would not be used further, and that memory for them could be freed.
This was beneficial as we were considering how to stream very long circuits, before we created IR functions.</p>
</div>
<div class="paragraph">
<p>As we added functions we we found it difficult for the backend to actually delete wires while maintaining adequate performance.
No longer was the IR&#8217;s implementation a single append-only list, now we wanted delete segments from it and pass segments to sub-functions.
So we put in restrictions to make memory management more manageable.</p>
</div>
<div class="paragraph">
<p>Consider a memory manager which allocates chucks of 8 wires at a time.
We have nice little 8-wire chunks, not too big not too small, and we can allocate as needed and delete on command.
What happens when we call a function that requires inputs in chunks of 10?
Now we have a problem: we could copy our 8-wire chunks in to new 10-wire chunks, but that&#8217;s too slow; we could make "super-chunks" which are composed of smaller chunks and pass the super-chunks, but that&#8217;s too complex.
What we came up with was to pass the problem on to the frontend.
While that seems like its just kicking the can to someone else, the frontend has more information about the problem they&#8217;re trying to solve.
For example, if the frontend is using some range of wires to represent an array, then they probably already know the array&#8217;s length and could have encoded that into the IR.
So we paired <code>@delete</code> with a <code>@new($first &#8230;&#8203; $last);</code> directive.
Now the frontend can request memory allocations of a particular size and delete them when finished.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// Allocate some wires
@new($0 ... $5);

/* assign and use them... */
$0 &lt;- /* ... */;
$1 &lt;- /* ... */;
/* ... */

// Now we're done, delete them.
@delete($0 ... $5);</pre>
</div>
</div>
<div class="paragraph">
<p>In a function call, any wire range must come from the same allocation.
Output wire ranges may be implicitly allocated, but if prior allocations conflict, then a problem would arise.
Let&#8217;s take a look at a few examples using the <code>mul4</code> and <code>dot4</code> functions which will multiply 4 pairs of wires and return the products and the sum-of-products respectively.</p>
</div>
<div class="paragraph">
<p>Here are the functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@function(mul4, @out: 0:4, @in: 0:4, 0:4)
  $0 &lt;- @mul($4, $8);
  $1 &lt;- @mul($5, $9);
  $2 &lt;- @mul($6, $10);
  $3 &lt;- @mul($7, $11);
@end

@function(dot4, @out: 0:1, @in: 0:4, 0:4)
  $9 &lt;- @mul($1, $5);
  $10 &lt;- @mul($2, $6);
  $11 &lt;- @mul($3, $7);
  $12 &lt;- @mul($4, $8);
  $13 &lt;- @add($9, $10);
  $14 &lt;- @add($11, $12);
  $0 &lt;- @add($13, $14);
@end</pre>
</div>
</div>
<div class="paragraph">
<p>This example would cause a problem because all the inputs are allocated singly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$0 &lt;- @private();
$1 &lt;- @private();
$2 &lt;- @private();
$3 &lt;- @private();
$4 &lt;- @private();
$5 &lt;- @private();
$6 &lt;- @private();
$7 &lt;- @private();

$8 &lt;- @call(dot4, $0 ... $3, $4 ... $7); // ERROR</pre>
</div>
</div>
<div class="paragraph">
<p>This example fixes it by allocating two ranges to pass to the function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@new($0 ... $3);
$0 &lt;- @private();
$1 &lt;- @private();
$2 &lt;- @private();
$3 &lt;- @private();
@new($4 ... $7);
$4 &lt;- @private();
$5 &lt;- @private();
$6 &lt;- @private();
$7 &lt;- @private();

$8 &lt;- @call(dot4, $0 ... $3, $4 ... $7); // Okay</pre>
</div>
</div>
<div class="paragraph">
<p>This example fixes it by allocating a single range and subseting the range as the function&#8217;s arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@new($0 ... $7);
$0 &lt;- @private();
$1 &lt;- @private();
$2 &lt;- @private();
$3 &lt;- @private();
$4 &lt;- @private();
$5 &lt;- @private();
$6 &lt;- @private();
$7 &lt;- @private();

$8 &lt;- @call(dot4, $0 ... $3, $4 ... $7); // Okay</pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the function&#8217;s output may even be a part of the original allocation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@new($0 ... $8);
$0 &lt;- @private();
$1 &lt;- @private();
$2 &lt;- @private();
$3 &lt;- @private();
$4 &lt;- @private();
$5 &lt;- @private();
$6 &lt;- @private();
$7 &lt;- @private();

$8 &lt;- @call(dot4, $0 ... $3, $4 ... $7); // Okay</pre>
</div>
</div>
<div class="paragraph">
<p>Now lets try with <code>mul4</code>.
This example works just fine, because <code>$8 &#8230;&#8203; $11</code> can be allocated implicitly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@new($0 ... $3);
$0 &lt;- @private();
$1 &lt;- @private();
$2 &lt;- @private();
$3 &lt;- @private();
@new($4 ... $7);
$4 &lt;- @private();
$5 &lt;- @private();
$6 &lt;- @private();
$7 &lt;- @private();

$8 ... $11 &lt;- @call(mul4, $0 ... $3, $4 ... $7); // Okay</pre>
</div>
</div>
<div class="paragraph">
<p>This one fails because the over allocation of the original range conflicts with implicit allocation of the call&#8217;s output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@new($0 ... $8);
$0 &lt;- @private();
$1 &lt;- @private();
$2 &lt;- @private();
$3 &lt;- @private();
$4 &lt;- @private();
$5 &lt;- @private();
$6 &lt;- @private();
$7 &lt;- @private();

$8 ... $11 &lt;- @call(mul4, $0 ... $3, $4 ... $7); // ERROR</pre>
</div>
</div>
<div class="paragraph">
<p>But extending the allocation to include  the call&#8217;s output fixes it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@new($0 ... $11);
$0 &lt;- @private();
$1 &lt;- @private();
$2 &lt;- @private();
$3 &lt;- @private();
$4 &lt;- @private();
$5 &lt;- @private();
$6 &lt;- @private();
$7 &lt;- @private();

$8 ... $11 &lt;- @call(mul4, $0 ... $3, $4 ... $7); // Okay</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Today we saw how functions can be used to encapsulate sub-circuits and be called repeatedly, which can drastically reduce the size of a circuit.
We also took a look at the IR&#8217;s memory management, enabling unused memory to be reclaimed mid-proof.
Both of these enable backends to run circuits with billions or trillions of gates, sometimes taking hours or days to complete.</p>
</div>
<hr>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
<div class="paragraph">
<p><strong>Distribution Statement "A":</strong> Approved for Public Release, Distribution Unlimited</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><category term="Circuit-IR" /><category term="v2.1.0" /><summary type="html"><![CDATA[The SIEVE IR&#8217;s function gates will encapsulate a subcircuit so it may be reused many times over. Doing this can drastically reduce the size of a circuit. This may seem unimportant, considering how an interactive proof is likely to have communication proportional to the number of gates, however IO of the relation has proved to be a bottleneck in the past, and some relations have taken terabytes of space. So, its worth it to attempt to compress the circuit as much as possible.]]></summary></entry><entry><title type="html">Introducing the SIEVE Circuit-IR: Multiple Types and Conversions</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/07/sieve-circuit-ir-multi-types-conversions.html" rel="alternate" type="text/html" title="Introducing the SIEVE Circuit-IR: Multiple Types and Conversions" /><published>2023-07-07T00:00:00-04:00</published><updated>2023-07-07T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/07/sieve-circuit-ir-multi-types-conversions</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/07/sieve-circuit-ir-multi-types-conversions.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In this series, we are examining the new SIEVE Circuit-IR.
This installment will examine its type system and how it enables multiple types to be combined within the same relation.</p>
</div>
<div class="paragraph">
<p>One goal of this revision of the SIEVE IR is to support multiple fields in the same circuit.
Although within a backend there may be significant distinctions between different fields, framing multiple fields, and even rings, as types of wires within the same circuit eases development for frontends.
In one application, we found ourselves needing to integrate four primes: a pair of large primes for ED-DSA signatures, 2 for computing SHA hashes, and 2<sup>61</sup>-1 for the proof&#8217;s "business logic".</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="declaring-types">Declaring Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To understand the SIEVE-IR&#8217;s type system lets take a closer look at the header.
The header&#8217;s we&#8217;ve seen so far have had just one field, but a circuits may list one or more types in its header (up to 256 types).
Each type is assigned a type index, starting at 0 and incrementing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@version 2.0.0;
circuit;
@type field 127; // type 0
@type field 2;   // type 1
@begin</pre>
</div>
</div>
<div class="paragraph">
<p>Prime fields are not the only types the IR allows.
It also allows extension fields () and rings (modulo 2<em>n</em>).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Prime Fields GF(<em>p</em>)</dt>
<dd>
<p>Prime fields behave like positive integers modulo some prime. Fields enjoy the broadest support by backends.</p>
<div class="ulist">
<ul>
<li>
<p><code>@type field [prime];</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Rings (modulo 2<sup><em>n</em></sup>)</dt>
<dd>
<p>Rings behave like positive integers modulo two to some power, <em>n</em>. They should feel familiar to anyone familiar with common unsigned int types.</p>
<div class="ulist">
<ul>
<li>
<p><code>@type ring [n];</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Extension Fields GF(<em>p<sup>n</sup></em>)</dt>
<dd>
<p>Extension fields are polynomials of some base prime field, up to some degree, <em>n</em>.
Rather than evaluating the polynomial at some particular point, we can add and multiply these by their coefficients, preventing the growth of new terms by modulus over an irreducible polynomial.
In the IR, extension fields are defined by a base field&#8201;&#8212;&#8201;the type index of a prior prime field, <em>baseidx</em>&#8201;&#8212;&#8201;and an integer encoding of the irreducible polynomial, <em>ipoly</em>.
<em>ipoly</em> is a single integer encoding of the coefficients, <em>c<sub>i</sub></em>, using the base field&#8217;s prime, <em>p</em>.
Most folk&#8217;s won&#8217;t need to use extension fields.</p>
<div class="ulist">
<ul>
<li>
<p><em>ipoly</em> = &#x03A3; <em>c<sub>i</sub></em> * <em>p<sup>i</sup></em></p>
</li>
<li>
<p><code>@type ext_field [baseidx] [n] [ipoly];</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-multiple-types">Using Multiple Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Within the body of a circuit, each wire&#8217;s number is actually a pair of the type index and then the wire number.
This means there&#8217;s a different numbering space for every type.
By default, a gate will assume the type index is 0, however non-zero types may use the form <code>@operation(index: $inputs)</code> to set the type index of all wires accessed by the gate.
In general, all of a gates operands are of the same type (the circuit&#8217;s meaning would be somewhat nonsensical otherwise).</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a sample circuit which uses prime fields 127 and 2.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  // private inputs in each field.
  $0 &lt;- @private(0); // wire 0:$0 (field 127, above)
  $0 &lt;- @private(1); // wire 1:$0 (field 2, above)

  // Add and mul in each fields.
  $1 &lt;- @add(0: $0, $0);
  $1 &lt;- @mul(1: $0, $0);
@end</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conversion-gates">Conversion Gates</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Of course having multiple types is somewhat useless without being able to interact them with each other.
For this we introduce the <code>@convert</code> gate which converts wires from one type to another.
The convert gate will convert input wire(s) to output wires by accumulating each input wire as if it were a digit in a larger integer, then re-digitizing them in the output field.
This way an <code>@convert</code> gate which outputs to GF(2) is the equivalent of a big endian bit decomposition, and GF(3) would be a trit-decomposition.</p>
</div>
<div class="paragraph">
<p>Concretely, the convert gate introduces a <em>wire range</em> syntax expressing a sequence of wires.
A range has the form, <code>$first &#8230;&#8203; $last</code>, meaning that every wire starting with <code>$first</code> up to and including <code>$last</code>.
Of course, <code>$first</code> must not be greater than <code>$last</code>, and if they are equal <code>$last</code> may be omitted.
Wire ranges serving as inputs must also obey memory contiguity rules, which will be discussed further on in this post.
For now, the <code>@new($first &#8230;&#8203; $last);</code> directive will allocate contiguous space for any necessary range.</p>
</div>
<div class="paragraph">
<p>The convert gate has the syntax <code>out_type: $output_first &#8230;&#8203; $output_last &#8592; @convert(in_type: $input_first &#8230;&#8203; $input_last);</code>.
When applicable, <code>&#8230;&#8203; $output_last</code> and <code>&#8230;&#8203; $input_last</code> may be omitted.
Here&#8217;s an example converting between GF(2), and GF(7).</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@version 2.0.0;
circuit;
@type field 2; // type 0
@type field 7;   // type 1
@begin
  // Convert all zeros
  @new($0...$2);
  $0 &lt;- 0: &lt;0&gt;; // assigns a constant
  $1 &lt;- 0: &lt;0&gt;;
  $2 &lt;- 0: &lt;0&gt;;

  1: $0 &lt;- @convert(0: $0 ... $2); // Converts to 0

  // Convert 1
  @new($3...$5);
  $3 &lt;- 0: &lt;0&gt;;
  $4 &lt;- 0: &lt;0&gt;;
  $5 &lt;- 0: &lt;1&gt;;

  1: $1 &lt;- @convert(0: $3 ... $5); // Converts to 1

  // Convert 6
  @new($6...$8);
  $6 &lt;- 0: &lt;1&gt;;
  $7 &lt;- 0: &lt;1&gt;;
  $8 &lt;- 0: &lt;0&gt;;

  1: $2 &lt;- @convert(0: $3 ... $5); // Converts to 6

  // Convert 7
  @new($9...$11);
  $9 &lt;- 0: &lt;1&gt;;
  $10 &lt;- 0: &lt;1&gt;;
  $11 &lt;- 0: &lt;1&gt;;

  1: $3 &lt;- @convert(0: $3 ... $5); // Converts to 7?!
@end</pre>
</div>
</div>
<div class="paragraph">
<p>The last example <em>1,1,1</em> should convert to <em>7</em>, but that overflows the field.
The convert gate has an optional <code>@modulus</code> or <code>@no_modulus</code> tag specifying how it handles overflow, <code>@convert(/* &#8230;&#8203; */, @no_modulus)</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In <code>@modulus</code> mode an overflowing value wraps around modularly, in this case back to 0.</p>
</li>
<li>
<p>In <code>@no_modulus</code> mode an overflow causes the proof to be false&#8201;&#8212;&#8201;same as <code>@assert_zero</code> of a non-zero wire.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Today&#8217;s installment overviewed how the Circuit-IR enables a proof to utilize multiple types, and convert wires from one type to another.
Generally, conversions are fairly expensive in ZK, and should be avoided when possible.
Sometimes they are necessary&#8201;&#8212;&#8201;when a subcomputation cannot be performed in one type, or when the savings from performing a subcomputation in an alternative field exceeds the cost of conversion.</p>
</div>
<div class="paragraph">
<p>Next up, we will have a look at Circuit-IR functions and memory management, features which enable a great amount of scalability.</p>
</div>
<hr>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
<div class="paragraph">
<p><strong>Distribution Statement "A":</strong> Approved for Public Release, Distribution Unlimited</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><category term="Circuit-IR" /><category term="v2.1.0" /><summary type="html"><![CDATA[In this series, we are examining the new SIEVE Circuit-IR. This installment will examine its type system and how it enables multiple types to be combined within the same relation.]]></summary></entry><entry><title type="html">Introducing the SIEVE Circuit-IR: Basics</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/06/introducing-the-sieve-circuit-ir-basics.html" rel="alternate" type="text/html" title="Introducing the SIEVE Circuit-IR: Basics" /><published>2023-07-06T00:00:00-04:00</published><updated>2023-07-06T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/06/introducing-the-sieve-circuit-ir-basics</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2023/07/06/introducing-the-sieve-circuit-ir-basics.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://www.darpa.mil/program/securing-information-for-encrypted-verification-and-evaluation">DARPA SIEVE Program</a> has been developing the <a href="https://github.com/sieve-zk/ir">SIEVE Intermediate Representation</a> for about three years, and we recently achieved our second public release: the Circuit Intermediate Representation.
As one of the primary developers of it, team Wizkit will again blog about its development and workings.
Today we&#8217;ll start a series overviewing the SIEVE Circuit Intermediate Representation (Circuit-IR) language and semantics, and of course our own <a href="https://stealthsoftwareinc.github.io/wiztoolkit">WizToolKit library</a> for this revision of the Circuit-IR.</p>
</div>
<div class="paragraph">
<p>An Intermediate Representation (IR) is a term borrowed from the field of programming language development, a sensible borrow for what is essentially "programmable cryptography".
Typically, an IR is the representation of a program within a compiler: a common understanding of the program between the frontend (which handles the input language) and backend (which outputs machine code).
In the SIEVE Program, some teams have developed frontends which accept various input languages, while other teams have developed backends which prove statements in Zero Knowledge, rather than emitting machine code.
The SIEVE Circuit-IR is a common understanding of ZK statements between SIEVE frontends and backends.</p>
</div>
<div class="paragraph">
<p>Throughout this series "IR" will refer specifically to the SIEVE Circuit-IR.</p>
</div>
<div class="paragraph">
<p>Although this post is about a revision to the SIEVE IR, we don&#8217;t expect you to have read prior posts in order to read this one.
You can (and probably should) read this post as if you&#8217;ve never heard of the SIEVE IR before.
We do expect you to have a basic familiarity with Zero-Knowledge Proofs (ZK) and finite field arithmetic in GF(<em>p</em>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-zero-knowledge-setting">The Zero Knowledge Setting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Zero Knowledge we have two parties: the prover and the verifier.
The prover has some secret and wishes to convince the verifier that some falsifiable fact about their secret is true, without revealing the secret.
For example, a company may have a user database which the wish to keep secret to protect the privacy of their patrons.
But regulators may wish to inspect the user database to ensure that the company doesn&#8217;t collect information about children below the age of 13.
Instead of opening up and showing their user database to the regulators, the company can make a zero knowledge proof stating that each user&#8217;s age is greater than 13.</p>
</div>
<div class="paragraph">
<p>This example illustrates all the fundamental components of the inputs to a ZK Proof.
The prover has a <em>private input</em>&#8201;&#8212;&#8201;their user database.
The prover and verifier both know a <em>public input</em>&#8201;&#8212;&#8201;the threshold age of 13 (new regulations could change this to 12 or 14, for example).
Most importantly there is a <em>relation</em> which connects both inputs to form some falsifiable fact: that each user&#8217;s age is greater than the threshold.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-circuit">The Circuit</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The SIEVE-IR&#8217;s relation is based on circuits&#8201;&#8212;&#8201;gates connected by wires.
Most gates produce one output wire, specifying a wire number for it to be referenced as inputs to subsequent gates.
Gates have the form <code>$output &#8592; @operation($inputs&#8230;&#8203;);</code>, with the output wire on the left of an arrow, followed by an operation and a parenthesized list of inputs.
Wire numbers are prefixed with a <code>$</code>, operations with an <code>@</code>, and numeric constants, where allowed, are surrounded by angle brackets (<code>&lt;12345&gt;</code>).
Wire numbers are often consecutive, but do not need to be.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s introduce each gate through a quick example.
We&#8217;ll prove that a triangle is a right triangle using the Pythagorean Theorem.
Three side-lengths will be used to prove that <em>a</em><sup>2</sup> + <em>b</em><sup>2</sup> = <em>c</em><sup>2</sup>.</p>
</div>
<div class="sect2">
<h3 id="input-gates-and-input-streams">Input Gates and Input Streams</h3>
<div class="paragraph">
<p>The first kind of gate you&#8217;ll encounter is an "input" gate.
The IR represents the circuit&#8217;s <em>public and private inputs</em> using streams&#8201;&#8212;&#8201;sequences of values which the circuit may access one at at time.
The IR has one stream for <em>private inputs</em> and another for <em>public</em> ones.
The <code>$n &lt;- @public();</code> and <code>$n &lt;- @private();</code> gates will read the next wire from a stream and assign it to a wire.
In our example, let&#8217;s read two public legs and the hypotenuse from the private input stream.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$0 &lt;- @public(); // leg a
$1 &lt;- @public(); // leg b
$2 &lt;- @private(); // hypotenuse c</pre>
</div>
</div>
<div class="paragraph">
<p>The streams themselves are simply lists of values, preceded by a little bit of header information (the IR version, a public or private keyword, the prime field).</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-bottom">Public Input Stream</th>
<th class="tableblock halign-left valign-bottom">Private Input Stream</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-bottom"><div class="content"><div class="listingblock">
<div class="content">
<pre>@version 2.1.0;
public_input;
@type field 127;
@begin
  &lt;3&gt;; // leg a
  &lt;4&gt;; // leg b
@end</pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-bottom"><div class="content"><div class="listingblock">
<div class="content">
<pre>@version 2.1.0;
private_input;
@type field 127;
@begin
  &lt;5&gt;; // hypotenuse c

@end</pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="arithmetic-gates">Arithmetic Gates</h3>
<div class="paragraph">
<p>Arithmetic gates are the main workers of all circuits.
The <code>@mul</code> and <code>@add</code> input two wires and output either their product or sum.
We can use <code>@mul</code> to square each input, and <code>@add</code> to add <em>A</em> and <em>B</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$3 &lt;- @mul($0, $0); // A**2
$4 &lt;- @mul($1, $1); // B**2
$5 &lt;- @mul($2, $2); // C**2

$6 &lt;- @add($3, $4); // A**2 + B**2</pre>
</div>
</div>
<div class="paragraph">
<p>Built into the IR, we can only compare wires to 0, not to each other.
Therefore, we must rewrite <em>A</em><sup>2</sup> + <em>B</em><sup>2</sup> = <em>C</em><sup>2</sup> to become <em>A</em><sup>2</sup> + <em>B</em><sup>2</sup> - <em>C</em><sup>2</sup> = 0.
To perform subtraction in the IR we multiply the right operand by <em>P</em> - 1&#8201;&#8212;&#8201;-1 in a finite field&#8201;&#8212;&#8201;and then use addition.
To multiply by a constant we use the <code>$output &lt;- @mulc($input, &lt;constant&gt;);</code> gate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$7 &lt;- @mulc($5, &lt;126&gt;); // If our prime is 127, then 126 == -1
$8 &lt;- @add($6, $7); // A**2 + B**2 - C**2</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="assert-zero">Assert Zero</h3>
<div class="paragraph">
<p>The last gate we need is <code>@assert_zero($input);</code>.
This gate proves that a wire is (or is not) equal to zero.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@assert_zero($8);</pre>
</div>
</div>
<div class="paragraph">
<p>Putting this together, along with a header (again the IR version, a public or private keyword, the prime field) we get the following circuit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@version 2.1.0;
public_input;
@type field 127;
@begin
  $0 &lt;- @public(); // leg A
  $1 &lt;- @public(); // leg B
  $2 &lt;- @private(); // hypotenuse C

  $3 &lt;- @mul($0, $0); // A**2
  $4 &lt;- @mul($1, $1); // B**2
  $5 &lt;- @mul($2, $2); // C**2

  $6 &lt;- @add($3, $4); // A**2 + B**2

  $7 &lt;- @mulc($5, &lt;126&gt;); // If our prime is 127, then 126 == -1
  $8 &lt;- @add($6, $7); // A**2 + B**2 - C**2

  @assert_zero($8);
@end</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="wiztoolkit">WizToolKit</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can give these circuits a try with <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v2.1.0/4_tools/firealarm.html">WizToolKit&#8217;s <code>wtk-firealarm</code> tool</a>.
WizToolKit is a library for working with the SIEVE IR, and the <code>wtk-firealarm</code> tool runs proofs in the Non-ZK setting&#8201;&#8212;&#8201;good for testing, debugging, and trying things out.
You can <a href="https://github.com/stealthsoftwareinc/wiztoolkit">download WizToolKit</a> and install with <code>make &amp;&amp; sudo make install</code>.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re a ZK backend developer you can have a look at our <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v2.1.0/2_nails.html">integration tutorials</a> and <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v2.1.0/6_sample_backends/0_intro.html">backend starter code</a>.
Regardless of whether or not you develop ZK backends, you can take a look at some of our <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v2.1.0/5_testcases.html">test circuit generators</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This post showed off the basics of using the SIEVE Circuit-IR.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The numbered wiring system to connect gates,</p>
</li>
<li>
<p>Accepting inputs from public and private streams,</p>
</li>
<li>
<p>And using arithmetic gates to define a relation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In upcoming posts we&#8217;ll take a look at more aspects of the IR: multi field circuits/field switching, its type system, and how functions can be defined to increase scalability.</p>
</div>
<hr>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
<div class="paragraph">
<p><strong>Distribution Statement "A":</strong> Approved for Public Release, Distribution Unlimited</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><category term="Circuit-IR" /><category term="v2.1.0" /><summary type="html"><![CDATA[The DARPA SIEVE Program has been developing the SIEVE Intermediate Representation for about three years, and we recently achieved our second public release: the Circuit Intermediate Representation. As one of the primary developers of it, team Wizkit will again blog about its development and workings. Today we&#8217;ll start a series overviewing the SIEVE Circuit Intermediate Representation (Circuit-IR) language and semantics, and of course our own WizToolKit library for this revision of the Circuit-IR.]]></summary></entry><entry><title type="html">Simulating Boolean Computations with GF(p) Circuits</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2023/05/11/simulating-bool-in-GFp.html" rel="alternate" type="text/html" title="Simulating Boolean Computations with GF(p) Circuits" /><published>2023-05-11T00:00:00-04:00</published><updated>2023-05-11T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2023/05/11/simulating-bool-in-GFp</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2023/05/11/simulating-bool-in-GFp.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In ZK Proofs it is difficult to compute some common operations because the typical <code>GF(p)</code> operations only allow two useful operations: addition and multiplication.
From these two simple operations, many others can be built, but many others cannot.
For example, exact equality or inequality can take advantage of <a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem">Fermat&#8217;s Little Theorem</a>, and from this we can build multiplexers to implement conditionals.
But comparative inequalities (less than, greater than, etc) are still impossible without further work.
In this post we&#8217;ll start by simulating Boolean logic in <code>GF(p)</code>, then build up to comparison operations, and show how we can use these to simulate integer division.</p>
</div>
<div class="paragraph">
<p>To read this post you should be familiar with prime-modulus finite fields (<code>GF(p)</code>), Boolean arithmetic, and with Zero Knowledge Proofs as a concept.
I&#8217;ll also use snippets of C code for demonstration, along with truth-tables.
In C code, I&#8217;ll use <code>unsigned int</code> and show modular operations with <code>(expr) % P</code>.</p>
</div>
<div class="paragraph">
<p>Throughout this example we&#8217;ll use the prime <code>101</code>, and we know that its bit-width is <code>7</code>.
We&#8217;ll also use big-end first bit vectors, where relevant.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">101</span><span class="tok-p">;</span>
<span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">P_WIDTH</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">7</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="simulated-boolean-basics">Simulated Boolean Basics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To simulate Booleans we want values in <code>GF(p)</code>, but we want to constrain them such that they only ever equal <code>0</code> or <code>1</code>.
In ZK, it is easy to check that a value is equal to zero (for example with the SIEVE IR <code>@assert_zero</code> directive).
We can take advantage of this to make a simple test proving to the verifier that a value is in fact a Boolean value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">assert_boolean</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">v</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-n">assert</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">v</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">v</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">));</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>v == 0</code>, this multiplies out as <code>0</code>, and when <code>v == 1</code> then <code>v - 1</code> multiplies out to <code>0</code>.
For any other value of <code>v</code>, it multiplies out to something non-zero.</p>
</div>
<div class="paragraph">
<p>Next we want some simple Boolean operations <code>and</code>, <code>or</code>, <code>xor</code>, etc.
<code>and</code> is the simplest because it is just multiplication.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>l</code></th>
<th class="tableblock halign-left valign-top"><code>r</code></th>
<th class="tableblock halign-left valign-top"><code>l &amp;&amp; r</code></th>
<th class="tableblock halign-left valign-top"><code>l * r</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>So we can make a simple function for Boolean and.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-nf">bool_and</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">l</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">r</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-k">return</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">l</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">r</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>or</code> and <code>xor</code> (inclusive and exclusive or) are a bit trickier.
Addition is a good first try, but it produces <code>2</code> in the case where both operands are <code>1</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>l</code></th>
<th class="tableblock halign-left valign-top"><code>r</code></th>
<th class="tableblock halign-left valign-top"><code>l || r</code></th>
<th class="tableblock halign-left valign-top"><code>l + r</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2</code> BAD</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The next try is to notice that we already know that last case from <code>and</code>, so we can get rid of it by subtraction.
For <code>or</code> we subtract once, and <code>xor</code> we subtract twice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">NEG1</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">P</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>

<span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-nf">bool_or</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">l</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">r</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-k">return</span><span class="tok-w"> </span><span class="tok-p">((</span><span class="tok-n">l</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-n">r</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">NEG1</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">l</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">r</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">))</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">NEG2</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">NEG1</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-mi">2</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>

<span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-nf">bool_xor</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">l</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">r</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-k">return</span><span class="tok-w"> </span><span class="tok-p">((</span><span class="tok-n">l</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-n">r</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">NEG2</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">l</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">r</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">))</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we get the truth tables we want.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>l</code></th>
<th class="tableblock halign-left valign-top"><code>r</code></th>
<th class="tableblock halign-left valign-top"><code>bool_or(l, r)</code></th>
<th class="tableblock halign-left valign-top"><code>bool_xor(l, r)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Lastly, the obvious implementation of <code>not</code> would be to <code>xor</code> by <code>1</code>.
But a colleague showed me a trick where you multiply by <code>-1</code> and then add 1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-nf">bool_not</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">v</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-k">return</span><span class="tok-w"> </span><span class="tok-p">((</span><span class="tok-n">v</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">NEG1</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Unfortunately, every Boolean gate now costs a multiplication, instead of the "free xor" most ZK practitioners are accustomed to from legitimate Boolean ZK.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bit-decomposition">Bit Decomposition</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bit decomposition takes an arithmetic value, and produces bits, such that the total of all bits multiplied by their place all add back up to the original value.
In general there will be <code>ceiling(log_2(P))</code> many bits for any field element <code>v</code>.
In plaintext, the prover&#8201;&#8212;&#8201;who knows all the values in the circuit&#8201;&#8212;&#8201;can decompose to bits as follows.
Then the prover can insert the bits as witness values into a circuit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">value</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* value to be decomposed */</span><span class="tok-p">;</span>

<span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-p">];</span>

<span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">val_cpy</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">value</span><span class="tok-p">;</span>
<span class="tok-k">for</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-w"> </span><span class="tok-o">&lt;=</span><span class="tok-w"> </span><span class="tok-n">P_WIDTH</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-n">bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-p">]</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">val_cpy</span><span class="tok-w"> </span><span class="tok-o">&amp;</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">;</span>
<span class="tok-w">  </span><span class="tok-n">val_cpy</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">val_cpy</span><span class="tok-w"> </span><span class="tok-o">&gt;&gt;</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course the verifier isn&#8217;t about to believe that the prover got those all correct, so the prover needs to convince the verifier of the following three conditions.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Each bit is in fact a bit (Perhaps with the prior defined <code>assert_boolean</code> function)</p>
</li>
<li>
<p>The bits add up to the original value</p>
</li>
<li>
<p>And that the prover hasn&#8217;t exploited overflow with a value between <code>P</code> and <code>pow(2, P_WIDTH)</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The first two are easy to show using existing ZK functionality, as shown in the following snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">recomp</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">bits</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">];</span>
<span class="tok-n">assert_boolean</span><span class="tok-p">(</span><span class="tok-n">bits</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]);</span>

<span class="tok-k">for</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-w"> </span><span class="tok-o">&lt;</span><span class="tok-w"> </span><span class="tok-n">P_WIDTH</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-n">assert_boolean</span><span class="tok-p">(</span><span class="tok-n">bits</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">]);</span>

<span class="tok-w">  </span><span class="tok-n">recomp</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-p">((</span><span class="tok-n">recomp</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-mi">2</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-n">bits</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">])</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-n">assert</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">recomp</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">NEG1</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Proving that overflow has not been exploited will require a less-than comparison.
A decomposition of <code>P</code> can be provided in the instance&#8201;&#8212;&#8201;known to both prover and verifier&#8201;&#8212;&#8201;so that a verifiable decomposition is known to the verifier.
The next section will show the actual implementation of a less than circuit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">prime_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-p">]</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* verifier already knows this */</span><span class="tok-p">;</span>
<span class="tok-n">assert</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">less_than_bits</span><span class="tok-p">(</span><span class="tok-n">prime_bits</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">bits</span><span class="tok-p">));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To better understand why this comparison is necessary, consider the case where the prover attempts to cheat by fudging the decomposition, inserting decomposition of a number greater than <code>P</code> when possible.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-n">val_cpy</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">value</span><span class="tok-p">;</span>
<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">val_cpy</span><span class="tok-w"> </span><span class="tok-o">&lt;</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-mi">1</span><span class="tok-w"> </span><span class="tok-o">&lt;&lt;</span><span class="tok-w"> </span><span class="tok-n">P_WIDTH</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-n">val_cpy</span><span class="tok-w"> </span><span class="tok-o">+=</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the recomposition&#8201;&#8212;&#8201;modulo <code>P</code>&#8201;&#8212;&#8201;would add up to the original value, but comparisons could be switched because the decomposition bits represents a much larger integer than they should.
The only way to prevent this is with the extra comparison to <code>P</code>'s decomposition, which the verifier already knows.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="comparison-circuits">Comparison Circuits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Comparing two bits has a fairly simple truth table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>l</code></th>
<th class="tableblock halign-left valign-top"><code>r</code></th>
<th class="tableblock halign-left valign-top"><code>l == r</code></th>
<th class="tableblock halign-left valign-top"><code>l &lt; r</code></th>
<th class="tableblock halign-left valign-top"><code>l &#8656; r</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For equality we get <code>(l &amp;&amp; r) || (!l &amp;&amp; !r)</code>, but a careful examination will show us that the truth table is the opposite of <code>xor</code>, cutting us down to just 2 multiplications.
For strict less than, we get <code>!l &amp;&amp; r</code>, also just two multiplications.
For less than or equal, because strict less than and equal share no common rows in the truth-table a simple <code>add</code> will suffice to combine them.
But even better, since a number is composed of many bits, we can postpone this add until each bit has been combined with its neighbors.</p>
</div>
<div class="paragraph">
<p>To combine them we&#8217;ll look at the truth table for "previous bits' equality", <code>p</code>, along with <code>l &lt; r</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>p</code></th>
<th class="tableblock halign-left valign-top"><code>l</code></th>
<th class="tableblock halign-left valign-top"><code>r</code></th>
<th class="tableblock halign-left valign-top"><code>p &amp;&amp; (l &lt; r)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>What we&#8217;ve done here is <code>and</code> the less than comparator with a bit indicating if all prior bits were equal.
If a higher placed bit were inequal, then that value should take priority.</p>
</div>
<div class="paragraph">
<p>We can combine all these truth tables into a simple comparison function.
Again, when combining prior comparisons we can use addition in place of an <code>or</code>, as we know that if a higher placed bit were inequal, then this comparison will be <code>0</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-nf">bits_less_than</span><span class="tok-p">(</span>
<span class="tok-w">    </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">l_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-p">],</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-p">])</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">lt</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">bool_and</span><span class="tok-p">(</span><span class="tok-n">bool_not</span><span class="tok-p">(</span><span class="tok-n">l_bits</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]),</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]);</span>
<span class="tok-w">  </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">p</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">bool_not</span><span class="tok-p">(</span><span class="tok-n">bool_xor</span><span class="tok-p">(</span><span class="tok-n">l_bits</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">],</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]));</span>

<span class="tok-w">  </span><span class="tok-k">for</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-w"> </span><span class="tok-o">&lt;</span><span class="tok-w"> </span><span class="tok-n">P_WIDTH</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">tmp_lt</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">bool_and</span><span class="tok-p">(</span><span class="tok-n">bool_not</span><span class="tok-p">(</span><span class="tok-n">l_bits</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">]),</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">]);</span>
<span class="tok-w">    </span><span class="tok-n">lt</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">bool_and</span><span class="tok-p">(</span><span class="tok-n">p</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">tmp_lt</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-n">lt</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>

<span class="tok-w">    </span><span class="tok-n">p</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">bool_and</span><span class="tok-p">(</span><span class="tok-n">p</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">bool_not</span><span class="tok-p">(</span><span class="tok-n">bool_xor</span><span class="tok-p">(</span><span class="tok-n">l_bits</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">],</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">])));</span>
<span class="tok-w">  </span><span class="tok-p">}</span>

<span class="tok-w">  </span><span class="tok-k">return</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">bool_and</span><span class="tok-p">(</span><span class="tok-n">bool_and</span><span class="tok-p">(</span>
<span class="tok-w">          </span><span class="tok-n">bool_not</span><span class="tok-p">(</span><span class="tok-n">l_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">]),</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">]),</span><span class="tok-w"> </span><span class="tok-n">p</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-n">lt</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Less than or equal is a nearly identical function, changing only the last line so that less-than and equality are added together.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-nf">bits_less_than_equal</span><span class="tok-p">(</span>
<span class="tok-w">    </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">l_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-p">],</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-p">])</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">lt</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-w">  </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">p</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>

<span class="tok-w">  </span><span class="tok-k">for</span><span class="tok-p">(</span><span class="tok-cm">/* ... */</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* ... */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>

<span class="tok-w">  </span><span class="tok-n">lt</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">bool_and</span><span class="tok-p">(</span><span class="tok-n">bool_and</span><span class="tok-p">(</span>
<span class="tok-w">          </span><span class="tok-n">bool_not</span><span class="tok-p">(</span><span class="tok-n">l_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">]),</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">]),</span><span class="tok-w"> </span><span class="tok-n">p</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-n">lt</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>
<span class="tok-w">  </span><span class="tok-k">return</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">bool_and</span><span class="tok-p">(</span><span class="tok-n">bool_not</span><span class="tok-p">(</span>
<span class="tok-w">          </span><span class="tok-n">bool_xor</span><span class="tok-p">(</span><span class="tok-n">l_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">],</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-w"> </span><span class="tok-o">-</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">])),</span><span class="tok-w"> </span><span class="tok-n">p</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-n">lt</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Comparing two <code>GF(p)</code> values is now a simple matter of composing bit decomposition with one of our comparators.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integer-division">Integer Division</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although integer division "doesn&#8217;t exist" in <code>GF(p)</code>, we can now allow the prover to calculate integer division in clear text and prove its correctness under ZK.
Given a numerator <code>n</code> and a denominator <code>d</code>, the prover can calculate a quotient <code>q</code> and remainder <code>r</code>.
Then the prover must prove the following two things</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>n == q*d + r</code></p>
</li>
<li>
<p><code>r &lt; d</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With a little bit of arithmetic, we can just use one of our recently developed comparison functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-c1">// return quotient, return remainder by pointer</span>
<span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-nf">int_division</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">d</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">q</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">q</span><span class="tok-p">;</span>

<span class="tok-w">  </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">I_AM_PROVER</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-n">q</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-w"> </span><span class="tok-o">/</span><span class="tok-w"> </span><span class="tok-n">d</span><span class="tok-p">;</span>
<span class="tok-w">    </span><span class="tok-o">*</span><span class="tok-n">r</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">d</span><span class="tok-p">;</span>
<span class="tok-w">  </span><span class="tok-p">}</span>

<span class="tok-w">  </span><span class="tok-n">assert</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-p">((</span><span class="tok-n">n</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">NEG1</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-p">((</span><span class="tok-n">q</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">d</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-n">r</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">%</span><span class="tok-w"> </span><span class="tok-n">P</span><span class="tok-p">);</span>

<span class="tok-w">  </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-p">];</span>
<span class="tok-w">  </span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">d_bits</span><span class="tok-p">[</span><span class="tok-n">P_WIDTH</span><span class="tok-p">];</span>
<span class="tok-w">  </span><span class="tok-n">bit_decompose</span><span class="tok-p">(</span><span class="tok-n">r_bits</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">r</span><span class="tok-p">);</span>
<span class="tok-w">  </span><span class="tok-n">bit_decompose</span><span class="tok-p">(</span><span class="tok-n">d_bits</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">d</span><span class="tok-p">);</span>

<span class="tok-w">  </span><span class="tok-n">assert</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">bits_less_than_equal</span><span class="tok-p">(</span><span class="tok-n">d_bits</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">r_bits</span><span class="tok-p">));</span>

<span class="tok-w">  </span><span class="tok-k">return</span><span class="tok-w"> </span><span class="tok-n">q</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this post we started out with just <code>GF(p)</code> arithmetic in ZK, and used that to simulate Boolean logic.
Unfortunately every Boolean gate wound up costing us a multiplication, but we saw a few tricks to occasionally eliminate them.
Then we decomposed field elements into bits and used the bits to make comparators.
Lastly, these enabled us to simulate division in <code>GF(p)</code>.
For convenience, I&#8217;ve attached a <a href="/attachments/bools/samples.c">sample C file</a> with this post&#8217;s example code.</p>
</div>
<hr>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
<div class="paragraph">
<p><strong>Distribution Statement "A":</strong> Approved for Public Release, Distribution Unlimited</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="circuits" /><category term="simple circuits" /><summary type="html"><![CDATA[In ZK Proofs it is difficult to compute some common operations because the typical GF(p) operations only allow two useful operations: addition and multiplication. From these two simple operations, many others can be built, but many others cannot. For example, exact equality or inequality can take advantage of Fermat&#8217;s Little Theorem, and from this we can build multiplexers to implement conditionals. But comparative inequalities (less than, greater than, etc) are still impossible without further work. In this post we&#8217;ll start by simulating Boolean logic in GF(p), then build up to comparison operations, and show how we can use these to simulate integer division.]]></summary></entry><entry><title type="html">Evolving the SIEVE IR: Our Concrete Proposal</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2022/09/26/evolving-the-sieve-ir-our-concrete-proposal.html" rel="alternate" type="text/html" title="Evolving the SIEVE IR: Our Concrete Proposal" /><published>2022-09-26T00:00:00-04:00</published><updated>2022-09-26T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2022/09/26/evolving-the-sieve-ir-our-concrete-proposal</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2022/09/26/evolving-the-sieve-ir-our-concrete-proposal.html"><![CDATA[<div class="paragraph">
<p>Over this summer, Team Wizkit developed a concrete proposal for an overhaul of the SIEVE Intermediate Representation.
While our proposal is a fairly radical departure from the original IR, we believe this proposal addresses our concerns about wire memory management and interoperability in the presence of wide differentiation between backend capabilities.
In the upcoming months the SIEVE Program will internally agree upon a final draft for the Phase II IR, but we hope that sharing our IR proposal with the wider community will help others engage with the IR as it continues to evolve.</p>
</div>
<div class="paragraph">
<p>Before reading our new proposal, you may want to review our prior post to <a href="/wizkit-blog/2022/05/26/replacing-the-sieve-ir.html">contextualize the changes our team proposes</a>.
Then have a look at <strong><a href="/wizkit-blog/attachments/ir2/wizkit_ir_proposal.pdf">our new IR2 proposal here (PDF downoad)</a></strong>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><category term="outdated" /><summary type="html"><![CDATA[Over this summer, Team Wizkit developed a concrete proposal for an overhaul of the SIEVE Intermediate Representation. While our proposal is a fairly radical departure from the original IR, we believe this proposal addresses our concerns about wire memory management and interoperability in the presence of wide differentiation between backend capabilities. In the upcoming months the SIEVE Program will internally agree upon a final draft for the Phase II IR, but we hope that sharing our IR proposal with the wider community will help others engage with the IR as it continues to evolve.]]></summary></entry><entry><title type="html">Getting Started with the SIEVE IR</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2022/08/04/getting-started-with-the-ir.html" rel="alternate" type="text/html" title="Getting Started with the SIEVE IR" /><published>2022-08-04T00:00:00-04:00</published><updated>2022-08-04T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2022/08/04/getting-started-with-the-ir</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2022/08/04/getting-started-with-the-ir.html"><![CDATA[<div class="paragraph">
<p>By now, you&#8217;ve read up on the SIEVE IR, you&#8217;re interested in ZK, and you&#8217;re ready to try it out the IR, but you&#8217;re not sure where to start.
For a ZK frontend, the IR opens up a world of backends, while for a backend it enables a wide variety of users to leverage your backend.
Well, here&#8217;s where to start: Team Wizkit has open sourced <a href="https://github.com/stealthsoftwareinc/wiztoolkit">WizToolKit</a> a collection of tools and libraries for working with the IR and <a href="https://github.com/emp-toolkit/emp-ir">EMP-IR</a> a ZK Backend which uses the IR.</p>
</div>
<div class="paragraph">
<p>For a ZK backend, a good place to start is with <a href="/wizkit-blog/2021/11/19/BOLT-two-pass-interpreter.html">WizToolKit&#8217;s BOLT API</a>.
BOLT is a callback-based API for handling ZK gates interpreted from the IR.
By implementing BOLT&#8217;s callbacks, your ZK Backend can easily and performantly ingest the SIEVE IR.
To get started check out our tutorials <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/backends.html">for using BOLT</a> and <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/parsers.html">for parsing the IR</a>.</p>
</div>
<div class="paragraph">
<p>For both frontends and backends, we have tools and demos to help you get started working the IR.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/tools/wtk-firealarm.html"><code>wtk-firealarm</code></a> can help you test and debug your IR circuits before you prove them in ZK. Its trace modes (<code>-t</code> or <code>-T</code> flags) can also help you sanity check when you&#8217;re struggling to debug your own ZK backends by printing out correct values for each wire in a circuit.</p>
</li>
<li>
<p><a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/tools/wtk-press.html"><code>wtk-press</code></a> can convert between the IR&#8217;s text and binary formats. It can also convert the IR&#8217;s <code>@switch</code> statements into multiplexer sub circuits&#8201;&#8212;&#8201;eliminating a large chunk of complexity for a backend.</p>
</li>
<li>
<p><a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/tools/wtk-viz.html"><code>wtk-viz</code></a> can convert an IR relation into a <a href="https://graphviz.org/">GraphViz</a> graph so that you can visualize your circuits.</p>
</li>
<li>
<p><a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/python/matrix_prod.py">The matrix product python script</a> can generate samples of the IR using various primes, test case sizes, and can switch between using loops or IR-Simple. Use these circuits to test and benchmark your backend and check out the source code for a demonstration of generating the IR.</p>
</li>
<li>
<p>Lastly, the <a href="https://github.com/emp-toolkit/emp-ir">EMP-IR</a> is a ZK backend ready for use with the IR. Test it out, or integrate it into your product.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the IR and our tooling sufficiently interests you, and you haven&#8217;t clicked away already then your best starting point is <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/install.html">the WizToolKit install guide</a> or <a href="https://github.com/emp-toolkit/emp-ir#installation">the EMP-IR install guide</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="WizToolKit" /><category term="SIEVE IR" /><category term="EMP" /><category term="outdated" /><summary type="html"><![CDATA[By now, you&#8217;ve read up on the SIEVE IR, you&#8217;re interested in ZK, and you&#8217;re ready to try it out the IR, but you&#8217;re not sure where to start. For a ZK frontend, the IR opens up a world of backends, while for a backend it enables a wide variety of users to leverage your backend. Well, here&#8217;s where to start: Team Wizkit has open sourced WizToolKit a collection of tools and libraries for working with the IR and EMP-IR a ZK Backend which uses the IR.]]></summary></entry><entry><title type="html">Replacing the SIEVE Intermediate Representation</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2022/05/26/replacing-the-sieve-ir.html" rel="alternate" type="text/html" title="Replacing the SIEVE Intermediate Representation" /><published>2022-05-26T00:00:00-04:00</published><updated>2022-05-26T00:00:00-04:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2022/05/26/replacing-the-sieve-ir</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2022/05/26/replacing-the-sieve-ir.html"><![CDATA[<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#the-layered-approach">The Layered Approach</a></li>
<li><a href="#independent-functions">Independent Functions</a></li>
<li><a href="#switching-between-multiple-fields">Switching between Multiple Fields</a></li>
<li><a href="#encapsulated-datastructures">Encapsulated Datastructures</a></li>
<li><a href="#pulling-it-back-together">Pulling it Back Together</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>During most of 2021, the Wizkit team worked with other SIEVE Performers to develop and implement the SIEVE IR.
Since it was finalized during summer 2021, we continued to push the envelope beyond what was demonstrated during the Phase I Testing Event.
We&#8217;ve also been one of the most active voices, within the SIEVE program, critically analyzing this IR.
In this blog post, we put the results of the critique to good use in making design suggestions for the next IR revision.</p>
</div>
<div class="paragraph">
<p>As we enter Phase II, Wizkit&#8217;s intention is to approach this round of IR development without much emphasis on maintaining backwards compatibility.
In this redesign, our view is that the <em>biggest drawback</em> to rectify is the treatment of the IR as a clean hand-off from TA1 (the human-facing language) to TA2 (the ZK proof system).</p>
</div>
<div class="paragraph">
<p>To really illustrate this point, essentially every TA2 backend in the SIEVE program has a format that they would prefer over the IR.
Wizkit&#8217;s EMP backend prefers to encode its circuits in compiled C++, while our Virgo backend prefers to extract its own structuring from a non-uniform circuit, and yet other backends just want R1CS.
Additionally, as TA2s gain functionality (such as batch/vector optimization, free disjunctions, or ZK RAM), the IR must match that functionality, leaving behind gaps where the program must shift resources around the moving IR.</p>
</div>
<div class="paragraph">
<p>Similarly, the program has encountered a number of situations where prime-specificity in the IR has been an issue.
First, across certain backends, sharing the same prime is not possible.
Some backends (for example <a href="https://github.com/emp-toolkit/emp-zk">EMP&#8217;s QuickSilver</a>) require <a href="https://oeis.org/A000668">Mersenne Primes</a> while other backends (such as <a href="https://dl.acm.org/doi/pdf/10.1145/3372297.3417893">Ligero</a>) require <a href="https://oeis.org/A080076">Proth Primes</a> which enable FFTs.
These sets are disjoint (aside from 3).</p>
</div>
<div class="paragraph">
<p>To further complicate this, some circuits are specific to a prime.
For example, the size and layout of a Fermat&#8217;s Little Theorem multiplexer depends on its prime due to its use of the fast exponent algorithm.
Another prime specific circuit is the EC-DSA public key signature&#8201;&#8212;&#8201;its implementation requires the use of specific pair of primes.
Yet other circuits, such as business logic, are largely agnostic to the prime so long as it is sufficiently large to avoid overflow.</p>
</div>
<div class="paragraph">
<p>These complications over primes have become a concern of the IR within the SIEVE program.
To resolve these issues, the program has discussed a number of solutions.
A parameter negotiation could allow TA2 to indicate preferred primes to TA1.
TA2 could be required to embed unsupported prime fields into supported ones.
The IR could allow for unspecified primes or even ring ZK (e.g. mod 2<sup>n</sup>).
As we add prime generalities to the IR, the boundary between TA1 and TA2 is further blurred into a gray-zone where both sets of expertise are necessary.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-layered-approach">The Layered Approach</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With this in mind, our team encourages a two-layer approach to the IR.
The top layer, or translation IR (also referred to as "IR2"), has the semantics of translating to the bottom layer.
The bottom layer, or circuit abstraction, is a largely flat non-uniform circuit similar to IR-Simple or IR0 (at this point those two terms are largely interchangeable).
The translation becomes a gray area where TA1 and TA2 must cooperate to produce either the circuit abstraction or a more suitable ZK format.
We also acknowledge that the integrated front/back-end effort may opt to directly evaluate the translation IR.</p>
</div>
<div class="paragraph">
<p>A benefit of the translation is that it can overcome naturally occuring incompatibilities such as prime mismatches.
Say that TA1 calls for a prime that a given TA2 cannot support.
In IR1, this was generally a show-stopper.
However, for IR2, the translation is an ideal place to replace an arithmetic circuit with a multi-bit boolean circuit or to embed a prime in an alternate field, for example using <a href="https://ieeexplore.ieee.org/document/8418647">xJsnark</a>.
The same could be done with RAM reductions, for TA2s that don&#8217;t natively support RAM.
In this way, TA1 may remain involved even after their compiler has emitted valid IR, compensating for the IR&#8217;s movement into traditionally "TA1 territory", and gaining functionality in the process.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="independent-functions">Independent Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Functions in IR1 were heavily dependent on both the size of the circuit and the circuit&#8217;s underlying field.
In IR2, the program seeks to develop a standard library of common functionality which frontends can utilize and backends can optimize.
Obviously, one cannot consider a library standard if it is heavily tied to attributes of a particular circuit.</p>
</div>
<div class="paragraph">
<p>With this in mind, the translation IR needs to decouple from both fields/primes and circuit sizes.
Rather than generating a new matrix multiplier for each matrix size and each field, a single function should handle all combinations of field and matrix size.
In order for this to happen we need to reexamine the IR&#8217;s first-class datatypes.</p>
</div>
<div class="paragraph">
<p>In IR1, the only first-class was a wire, the medium for propagating field elements.
In IR2, we&#8217;ll need at least three first-classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Wires</p>
</li>
<li>
<p>Fields</p>
</li>
<li>
<p>Circuit size parameters such as publicly known lengths, arrays, and indices</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These three types are the minimum required to implement <em>any</em> standard library functionality.
In general, IR2&#8217;s core language should be the minimum feature set required to host its standard library.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="switching-between-multiple-fields">Switching between Multiple Fields</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A particular functionality, which both TA2s are beginning to support and TA1s are eager to adopt, is field switching&#8201;&#8212;&#8201;the ability for a backend to convert wires from one field to another within a single circuit.
Because field switching involves a single circuit mixing fields, this is a further reason to adopt a first-class field type.
To go with this a new conversion gate must also be added to the IR&#8217;s core.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="encapsulated-datastructures">Encapsulated Datastructures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The IR needs an aggregate type to enable to enable backends to implement and optimize their own datastructures.
Essentially, this type must expose custom behaviors while encapsulating implementation and data.
We&#8217;ve been calling this a <code>capsule</code> to distinguish from the object-oriented <code>class</code> terminology (although we&#8217;re still thinking about other potential names, like <code>abstraction</code> or <code>interface</code>).
While this <code>capsule</code> type would be polymorphic much like an object-oriented <code>class</code>, there is a key distinction.
A <code>capsule</code> is provided and overridden by the backend&#8201;&#8212;&#8201;the IR&#8217;s interpreter&#8201;&#8212;&#8201;whereas a <code>class</code> is overridden by subclasses in the same language.</p>
</div>
<div class="paragraph">
<p>The first formative example we have for this is for ring ZK.
The ring element is encapsulated by the <code>capsule</code>, hidden from the frontend.
The frontend interacts only with the <code>capsule</code>'s behaviors: addition, multiplication, etc.
The backends may provide alternative implementations or even replace with a native implementation.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-bottom">Multi-Bit Ring Implementation</th>
<th class="tableblock halign-left valign-bottom">Large-Field Ring Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-bottom"><div class="content"><div class="listingblock">
<div class="content">
<pre>capsule UInt32
  private bool bits[32];


  @method(add, /* ... */)
    /* boolean adder */
  @end
  @method(mul, /* ... */)
    /* boolean multiplier */
  @end
@end</pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-bottom"><div class="content"><div class="listingblock">
<div class="content">
<pre>capsule UInt32
  private BigField value;
  public currWidth;

  @method(add, /* ... */)
    /* add, with occasional renormalize */
  @end
  @method(mul, /* ... */)
    /* multiply, with occasional renormalize */
  @end
@end</pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>This pseudo code should illustrate the <code>capsule</code>, and how it may be polymorphized by the backend.
It is not meant to to illustrate IR2 syntax details; those are yet to be determined.</p>
</div>
<div class="paragraph">
<p>The second example we have is ZK RAM.
In this case, the IR can implement a very naive RAM-like structure, and the backend may either override a native ZK RAM implementation, use a circuit-manipulating RAM reduction during translation, or fall back to the naive implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>capsule RAM(Field Elt, Field Idx, public len)
  private Elt buffer[len];

  @method(get, @in: private Idx idx, @out: private Elt ret)
    ret &lt;- Elt(0);
    ctr &lt;- Idx(0);
    @for e in this.buffer (@modifies ret, ctr)
      ret += e * (ctr == idx);
      ctr += 1;
    @end
  @end

  @method(set, @in: private Idx idx, private Elt elt,
       @modifies: buffer)
    /* ... */
  @end
@end</pre>
</div>
</div>
<div class="paragraph">
<p>Again, the pseudocode is illustrative of the <code>capsule</code>'s naivety and the opportunity for backend optimization, rather than exact IR syntax.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pulling-it-back-together">Pulling it Back Together</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Our team is excited to make right some of what we see as the IR&#8217;s shortcomings.
We believe that pairing a translation IR with a circuit abstraction is the best solution to cover both varying ZK format preferences amongst TA2s and increased variety of new functionality amongst all TA2s.
In developing the IR we want its core to be as minimal a feature set as possible, whilst enabling common functionality to be implemented in shared and standard libraries.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><category term="outdated" /><summary type="html"><![CDATA[During most of 2021, the Wizkit team worked with other SIEVE Performers to develop and implement the SIEVE IR. Since it was finalized during summer 2021, we continued to push the envelope beyond what was demonstrated during the Phase I Testing Event. We&#8217;ve also been one of the most active voices, within the SIEVE program, critically analyzing this IR. In this blog post, we put the results of the critique to good use in making design suggestions for the next IR revision.]]></summary></entry><entry><title type="html">BOLT, Two Pass IR Interpreter</title><link href="https://stealthsoftwareinc.github.io/wizkit-blog/2021/11/19/BOLT-two-pass-interpreter.html" rel="alternate" type="text/html" title="BOLT, Two Pass IR Interpreter" /><published>2021-11-19T00:00:00-05:00</published><updated>2021-11-19T00:00:00-05:00</updated><id>https://stealthsoftwareinc.github.io/wizkit-blog/2021/11/19/BOLT-two-pass-interpreter</id><content type="html" xml:base="https://stealthsoftwareinc.github.io/wizkit-blog/2021/11/19/BOLT-two-pass-interpreter.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In this installation about the SIEVE IR, we&#8217;re going to talk about speeding up a proof system without changing the underlying zero-knowledge mathemagic.
When we time a ZK backend using the IR we inadvertently time two distinct components&#8201;&#8212;&#8201;the backend itself and the time it takes to ingest a circuit.
The first component, the backend, is fairly well understood and many groups are working on optimizing this&#8201;&#8212;&#8201;faster math and less communication.
The second component is the topic of today&#8217;s post; it&#8217;s the time spent reading a gate and loading its operands before it can be processed in ZK.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If you&#8217;re looking for <em>how to use</em> BOLT, have a look at <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/backends.html">WizToolKit&#8217;s documentation for BOLT</a>. This post is about <em>how BOLT works</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We first looked into this problem after noticing that interpreting loops and functions was significantly slower in the IR than the IO and parsing time for an equivalent IR-Simple circuit&#8201;&#8212;&#8201;contrary to our expectation.
While some of the weaknesses outlined in our <a href="/wizkit-blog/2021/11/01/sieve-ir-v1.0-retrospective.html">IR Retrospective</a> certainly exacerbate the issue, we also stumble into the age old conflict of interpreters vs. compilers (Python vs. C, etc.).
While we have developed an extremely performant IR compiler, this post focuses on interpreters for the IR and takes half a step towards Just-In-Time (JIT) compilation.</p>
</div>
<div class="paragraph">
<p>The largest source of overhead which we encountered is searching for wires in lookup tables.
With loops and functions the lookup table must be built, destroyed and rebuilt on each iteration or invocation, causing significant slow downs.
We solve this problem by building an in memory data-structure where a single lookup table is built once and reused on many occurrences, and where each lookup operation is cached as a pointer into the table.
At the time of writing, we have already developed a partial prototype of this system.
This post will start out with results from the prototype in a non-ZK setting, then it will narrate development of the full system, and overview some results using the <a href="https://github.com/emp-toolkit/emp-zk">EMP-ZK backend</a>.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re unfamiliar with the SIEVE IR, you&#8217;ll want to read our <a href="/wizkit-blog/2021/09/20/introducing-the-sieve-ir.html">IR Introduction</a> and <a href="/wizkit-blog/2021/11/01/sieve-ir-v1.0-retrospective.html">Retrospective</a> before reading this.
You should also be prepared for some <a href="https://en.wikipedia.org/wiki/Mathematical_induction">proof by induction</a> and <a href="https://en.wikipedia.org/wiki/Unified_Modeling_Language">UML</a>.
We also clarify the following terms.
<strong>Overhead</strong>, in this context, is any time spent by a ZK proof system which isn&#8217;t directly related to the proof, so parsing and compiling or interpreting the circuit.
The <strong>parser</strong> is the first stage of processing the IR in which a sequence of characters matching the IR&#8217;s grammar is converted into a <strong>parse tree</strong> (or synonymously, syntax tree).
Both an IR compiler and interpreter will parse the IR, but the <strong>compiler</strong> will analyze the parse tree and produce an executable program which then performs the proof, while the <strong>interpreter</strong> will analyze the parse tree and perform a proof without an intermediate executable.
We further classify <strong>single-pass interpreters</strong> which immediately walk the parse tree and perform one step of the proof at each node, and <strong>multi-pass</strong> (or <strong>two, three, etc. -pass</strong>) <strong>interpreters</strong> which walk the tree multiple times, first doing analysis and building state data, then finally performing the proof.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prototype-and-early-results">Prototype and Early Results</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Our prototype succeeded in accelerating many samples of the IR, but it also entirely failed to interpret <code>@switch</code> statements and certain classes of <code>@for</code> loops.
Further we only developed it in a non-ZK setting.
That seems like a big failure for a supposedly ZK piece of equipment, but it gives us a lower bound the entire proof system&#8217;s runtime, e.g. how long would the proof take if ZK were entirely free.</p>
</div>
<div class="paragraph">
<p>After parsing, the prototype works in two phases.
First, the <strong>build phase</strong> analyzes the parse tree and rebuilds it with embedded lookup tables and cached pointers into those tables.
The build phase is able to embed most <em>public</em> semantics (such as "repeat this loop 5 times") into the tree.
Then the <strong>evaluate phase</strong> traverses the optimized parse tree and invokes a callback to handle each gate&#8217;s private semantics (such as "prove that `a * b == c`").
In the prototype we only implemented gate callbacks for the non-ZK setting, hence this limitation.</p>
</div>
<div class="paragraph">
<p>We were able to compare our BOLT prototype with <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/tools/wtk-firealarm.html">FIREALARM</a> (our non-ZK IR interpreter for debugging and development) as a single-pass baseline.
We used our <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/python/matrix_prod.py">matrix-multiply family of circuits</a> as test inputs to show scalability of this solution.</p>
</div>
<div class="paragraph">
<p>The figure compares runtimes for each phase of the IR processing solution, further broken down by the IR&#8217;s mode (simple or using loops).
It also shows target metrics for the SIEVE Program&#8217;s phases (arbitrary annual boundaries on our research).
During Phase II our target metric is 1 s/gate, which I&#8217;ve converted to wall-clock time for the appropriate gate count (red with dots).
During Phase III our target metric is 0.1 s/gate, again converted to wall-clock time (black with triangles).
Note that wall-clock time for a particular solution would be each of its phases summed together (e.g. parse time + firealarm time or parse time + build time + evaluate time).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/timing_motivation.png" alt="timing motivation">
</div>
<div class="title">Figure 1. Plot comparing the runtime of various phases in a FIREALARM or BOLT approach, <a href="/wizkit-blog/attachments/bolt/timing_motivation.csv">raw data</a></div>
</div>
<div class="paragraph">
<p>Before prototyping BOLT, the surprising result was that processing loops (orange with squares) was far slower than parsing (purple with vertical bars) and processing IR-Simple (aqua with stars).
End-to-end, the IR-Simple solution takes 0.121 s/gate (purple with bars plus aqua with stars), which is just a bit shy of the Phase III target and leaves no time for actually performing the proof.
This discrepancy is what motivated us to develop BOLT.</p>
</div>
<div class="paragraph">
<p>The prototype improves upon this in a few respects.
First, parsing additional iterations of a loop does not add to the parsing time.
In fact, for this test case (and likely many others), parsing loops is a small constant runtime (green with cross, partially covered along the bottom).
As it turns out, the build phase is also a nearly-zero constant (yellow with squares, along the bottom).
This leaves the evaluate phase (blue with circles), which is on par with parsing or processing IR-Simple.
Overall, the BOLT prototype managed 0.061 s/gate, which leaves a tight margin for performing the proof, but also has room for improvement.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="approach">Approach</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before getting into the design of BOLT, lets go over a quick example to animate the problem and how we solve it.
In the first animation, a vector dot product function of length 4 is shown.
Each frame traces a step of processing the sub-circuit in a single pass.
Many more frames show table lookups or insertions than show gate operations.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/single-pass-dotprod.gif" alt="Animation. It starts out showing an IR function with 1 output and 8 inputs wires. 4 multiplication gates multiply pairs of elements from the first 4 and last 4 input wires" width="then 3 addition gates sum the products. On each frame an arrow is draw from an element of the code to a table operation (lookup or insert) and then into a table. It starts out inserting two groups of four input wires" height="then the single output wire. Next">
</div>
<div class="title">Figure 2. A single pass interpreter processes a vector dot product.</div>
</div>
<div class="paragraph">
<p>Our second animation shows the approach of BOLT.
Rather than processing the parse tree directly, it is replaced with an alternate representation with pointers directly into a pre-built table.
On each gate, pointer reads and writes save time when compared to looking up or inserting to the table.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/multi-pass-dotprod.gif" alt="Animation. It starts out showing an IR-like function" width="however wire numbers in its body have been replaced with pointers. A memory table is also provided ahead of time. The function has 1 output and 8 input wires. 4 multiplication gates are shown followed by 3 addition gates. On each frame an arrow is drawn to or from one of the pointers from or to the table. It starts out by updating the table with two groups of four input wires. Then it updates a single wire reserved for function's output. Next" height="on each gate">
</div>
<div class="title">Figure 3. The BOLT interpreter processes a vector dot product.</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="design">Design</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before getting to the design, there are three numeric type abstractions.
The <code>wtk::index_t</code> (defined in <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/cpp/wtk/index.h"><code>wtk/index.h</code></a>) holds a wire-index, the <code>$</code> prefixed numbers indexing all wires in the IR.
The <code>wtk::index_t</code> is a simple <code>typedef</code> of <code>uint64_t</code>, thus capturing the <em>mod-2<sup>64</sup></em> behavior described for loop iterator-expressions and wire-numbers.
After that, BOLT is template-parameterized by the <code>Wire_T</code> and the <code>Number_T</code>.
The <code>Wire_T</code> is to encapsulate all values which the ZK Backend must carry between gates.
BOLT does not require it be a numeric type, although it is sometimes easy to think of it as such.
The <code>Number_T</code> holds field-literal values coming from the parser, before they&#8217;re mixed into <code>Wire_T</code>s.</p>
</div>
<div class="paragraph">
<p>BOLT has a pretty simple design at a high level.
BOLT connects <em>directives</em> directly to <em>wires</em> by rebuilding the IR syntax-tree and replacing the <code>wtk::index_t</code> indices with <code>Wire_T*</code> pointers.
The <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/cpp/wtk/IRTree.h">original syntax-tree</a> is fairly straight-forward, mirroring the grammar of the IR.
The BOLT structure is a bit more complicated and with wires being cross-referenced from "directive trees" to their storage space.</p>
</div>
<div class="paragraph">
<p>Directives are a simple tree-like structure, the <code>Bolt</code> struct (for lack of a better name) being the entry point.
For most directives, an "in-order" tree traversal should produce a correct evaluation.
When loops or function-gates are encountered, repetition of a particular sub-tree produces the correct evaluation (this will be elaborated in later subsections).
Wires are stored and looked up by the <code>WireSet</code> and <code>WireRange</code> families and connected to directives by the <code>WireRef</code> union-type.
The <code>WireRef</code> has two "addressing modes": <em>direct</em>, with a single pointer to a wire, and <em>indirect</em> with a pointer to and index in a <code>WireRange</code>.
BOLT does its best to use <em>direct</em> addressing as much as possible, however, <em>indirect</em> referencing is necessary when referencing for-loop iterator-expressions, or when reusing a function-gate at multiple call sites.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Two class-families are implemented as unions while shown as inheritance in UML (which conveniently pretends that unions do not exist).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Directives must be elements of the same list, even though they differ in function and purpose&#8201;&#8212;&#8201;not an "is a" relationship.</p>
</li>
<li>
<p><code>WireRef</code>s could use inheritance (and did in the original prototype), however as there are only two modes, the use of a union leads to a cleaner memory layout.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
BOLT (and WizToolKit in general) makes heavy use of a pool allocation pattern in which a "factory" or "builder" object produces some mess of structures, which take on the lifetime of the "factory".
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/UML_simple.png" alt="UML simple">
</div>
<div class="title">Figure 4. UML Diagram for BOLT (showing only simple directives). Along the top-left are the <code>WireRange</code> family, and along the bottom-right the <code>Directive</code> family. Connecting wires to directives the <code>WireRef</code> is above-center. The <code>Bolt</code> entry-point is pictured in the center-right, and its <code>WireSet</code> helper is below-center. Struct definitions can be found at <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/cpp/wtk/bolt/wires.h"><code>wtk/bolt/wires.h</code></a> and <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/cpp/wtk/bolt/directives.h"><code>wtk/bolt/directives.h</code></a></div>
</div>
<div class="paragraph">
<p>A <code>Builder</code> object (not shown) is responsible for translation of a single syntax-tree node (<code>wtk::DirectiveList</code>) into the BOLT structure.
If build succeeds, it guarantees that the relation, and consequently the produced BOLT structure, is well-formed and safe to evaluate.
The <code>Builder</code> optimizes the IR by analyzing one scope at a time.
In each scope, it follows these four steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Step 1: Reconstruct each scope&#8217;s memory layout.</p>
</li>
<li>
<p>Step 2: Preallocate space for wires.</p>
</li>
<li>
<p>Step 3: Rebuild each directive with pointers directly to preallocated space.</p>
</li>
<li>
<p>Step 4: Profit. (Well, okay. Execution of the scope will have a large constant-factor reduction in overhead)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Reconstruction is pretty simple.
We use a data structure which I&#8217;ve been calling a <em>SkipList</em> (although I&#8217;ve recently been informed that a <em>SkipList</em> is actually a multiply-linked-list with <em>O(log(n))</em> access time, which this is not).
My <em>SkipLists</em> are more like "ordered range sets": an ordered list of ranges (<code>first</code> and <code>last</code> pairs) which define membership.
Thus upon entry to any scope of the IR, the first thing to be done is to traverse all directives, and insert every assigned wire into a <em>SkipList</em>, the <em>"all list"</em>.</p>
</div>
<div class="paragraph">
<p>With all wires now accounted, they can be preallocated.
Local wires are to be allocated as <code>LocalWireRange</code>s in a <code>WireSet</code>.
The <code>WireSet.ranges</code> vector mirrors the structure of the local ranges within the <em>all list</em>.
Input and output wires are typically handled by the calling scope; we&#8217;ll cover them later.</p>
</div>
<div class="paragraph">
<p>Each directive is then rebuilt one by one.
At each directive, the wires must be checked, to ensure that the relation is indeed well-formed.
This is done with two additional <em>SkipLists</em>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>assigned</em></dt>
<dd>
<p>for wires which were assigned by previous directives.</p>
</dd>
<dt class="hdlist1"><em>deleted</em></dt>
<dd>
<p>to track <code>@delete</code>d wires.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Input wires must be members of the <em>assigned list</em> and non-members of the <em>deleted list</em>.
Output-wires are then inserted (with failure on duplication) into the <em>assigned list</em>.
Once the directive is deemed acceptable, each wire may be looked up and referenced: <code>Bolt.findWire(&#8230;&#8203;)</code> delegates to <code>WireSet.findRange(&#8230;&#8203;)</code> and <code>WireRange.ref(&#8230;&#8203;)</code>.</p>
</div>
<div class="paragraph">
<p>Most of the time, this will produce a pointer directly to the wire, allowing the evaluation phase to skip out on safety-checks and lookup costs.
<em>Evaluation</em> can still be considered safe, because the <em>Build</em> phase would have aborted before producing an unsafe pointer.
The performance gain is especially effective with loops, because repetition allows a single directive to be reused many times.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="remapping-wires-between-scopes">Remapping Wires Between Scopes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In lieu of a conventional lexical scoping scheme, the IR uses a local scoping scheme with "remapping" from the calling scope to a local scope.
Variances in remapping lead to a family of <code>WireRange</code>s, responsible for handling various cases of remapping.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Local</dt>
<dd>
<p>has ownership over a vector of wires in the local-scope. Lookup is performed via vector-indexing.</p>
</dd>
<dt class="hdlist1">Direct</dt>
<dd>
<p>is the simplest form of remapping, with a pointer into a containing scope&#8217;s local-scope. Lookup is performed via pointer-offset.</p>
</dd>
<dt class="hdlist1">Indirect</dt>
<dd>
<p>holds a pointer to another <code>WireRange</code>, to which all functionality is delegated.</p>
</dd>
<dt class="hdlist1">WireSet</dt>
<dd>
<p>Similar to <em>Indirect</em>, however it delegates to a <code>WireSet</code> rather than a <code>WireRange</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>Builder</code> takes the responsibility for checking that any <code>WireRange</code> is safe to dereference before it is built.
In other words, the construction of an unsafe <code>WireRange</code> would be indicative of a poorly-formed relation.
Each <code>WireRange</code> has three essential functionalities which the <code>Builder</code> must guard.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>producing a reference to a single wire (<code>ref(single)</code>),</p>
</li>
<li>
<p>producing a <code>WireRange</code> reference to itself or a subset of itself (<code>ref(range)</code>),</p>
</li>
<li>
<p>and dereferencing single wires within itself, as a requirement for <em>Indirect</em> referencing schemes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dashed arrows in the UML are used to indicate each <code>WireRange</code>'s means of reference.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/UML_functions.png" alt="UML functions">
</div>
<div class="title">Figure 5. UML Diagram for BOLT, simple directives are replaced with <code>AnonFunction</code>, <code>Function</code>, and <code>Invocation</code>. Additional <code>WireRange</code> forms are shown as needed for function gates.</div>
</div>
<div class="paragraph">
<p>The goal for BOLT is to produce as many <em>direct</em> references as possible.
In the following sub-sections, we&#8217;ll get into the remapping for each of the non-simple IR1 directives, starting from least to most complicated.</p>
</div>
<div class="sect2">
<h3 id="anonymous-function">Anonymous Function</h3>
<div class="paragraph">
<p>Anonymous functions are the easiest to remap, because they are used exactly once.
First, the caller will check for usability of the input wires in the <em>assigned</em> and <em>deleted SkipLists</em>, and then for assignability of the output wires.
When it knows the function is safe to call, it produces <em>direct</em> references for its local wires, and polymorphism&#8201;&#8212;&#8201;within its own remapped wire ranges&#8201;&#8212;&#8201;produces the simplest remapping it can for previously-remapped wires.</p>
</div>
</div>
<div class="sect2">
<h3 id="named-function">Named Function</h3>
<div class="paragraph">
<p>Named functions are slightly more difficult than anonymous ones, because they may be reused multiple times.
To save time during the build phase, we want to reuse the <code>Bolt</code> structure built for the function.
To do this, remapping must be split between the function-body and each invocation.</p>
</div>
<div class="paragraph">
<p>In the function-body, a placeholder wire range is mapped into the the <code>Bolt</code> body.
A <code>WireSetWireRangeRef</code> is used, with a <code>WireSet*</code> pointer initialized to null.
The placeholder creates <em>Indirect</em> references to itself, so that the body can be built.
During evaluation, the <code>WireSet*</code> pointer is changed to non-null so that actual wires can be referenced.</p>
</div>
<div class="paragraph">
<p>At the invocation site, wires from the caller&#8217;s scope are mapped into a <code>WireSet</code> using the similar rules to an Anonymous Function.
At evaluation time, this <code>WireSet</code> is pointed to by the function&#8217;s placeholder.</p>
</div>
</div>
<div class="sect2">
<h3 id="switch-statement">Switch Statement</h3>
<div class="paragraph">
<p>IR switch statements differ from conventional switches because all <code>@case</code>s must be processed to hide the switch condition wire.
After processing all <code>@case</code>s the output wires from the <em>selected</em> <code>@case</code> is multiplexed onto the <code>@case</code>'s output wires.
This is complicated by <code>@assert_zero</code> directives, which are disabled in <em>non-selected</em> <code>@case</code>s and by <code>@instance</code> and <code>@short_witness</code> directives which must share input values across cases to avoid blowup in the stream size.</p>
</div>
<div class="paragraph">
<p>Building and evaluating a switch statement is sort of a three step process.
Remember that each <code>@case</code> has its own input list (as either a named or an anonymous function), but all <code>@case</code>s share the <code>@switch</code>'s output list.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Each <code>@case</code>'s Instances and Witnesses counted and the maximum is taken as the <code>@switch</code>'s output count.</p>
<div class="ulist">
<ul>
<li>
<p>During evaluation, the <code>@switch</code> consumes inputs which are routed to <code>@instance</code> and <code>@short_witness</code> directives within the switch.</p>
</li>
</ul>
</div>
</li>
<li>
<p>"Dummy" output wires and "legitimate" input wires are mapped into each <code>@case</code>'s body.</p>
</li>
<li>
<p>During evaluation, after all <code>@case</code>s are evaluated, the dummies are multiplexed into the legitimate outputs.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Step one happens dynamically during evaluation, aside from counting the maximum consumption of instance and witness wires.
The <code>@switch</code> will consume all the necessary inputs and places them in a special buffer (<code>SwitchInputHandler</code>).
The body of each <code>@case</code> is given a pointer to the buffer in place of the normal streams (<code>wtk::InputStream</code>).
<code>@instance</code> and <code>@short_witness</code> directives copy wires from the buffer rather than consuming from the stream.</p>
</div>
<div class="paragraph">
<p>Step two is again fairly straight forward.
As each <code>@case</code> has none of its own output wires (only the <code>@switch</code>'s, at a top level), the total number of outputs can be counted, and a <code>LocalWireRange</code> may be allocated as "dummy" space for each <code>@case</code>.
Then the input wires can be mapped in, and processing of each <code>@case</code> continues the same as it would for a standard <code>@call</code> or <code>@anon_call</code>.
When processing the body during evaluation, a special <em>case-enabled</em> wire is carried to toggle inputs to <code>@assert_zero</code> directives.</p>
</div>
<div class="paragraph">
<p>The last step of build remaps each of the <code>@switch</code>'s outputs to a special <em>output</em> <code>WireSet</code>.
At evaluation, the dummy wires are multiplexed, and each result is assigned to the corresponding wire in the <em>output</em> <code>WireSet</code>.
The BOLT system defaults to the <em>Fermat&#8217;s Little Theorem</em> trick described in section 6.3 of the IR spec.
However, ZK backends could improve upon this with dynamic generation of additional witness values.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/UML_switches.png" alt="UML switches">
</div>
<div class="title">Figure 6. UML Diagram for BOLT&#8217;s switch-statement implementation. The <code>SwitchStatement</code> type relies on <code>Invocation</code> and <code>AnonFunction</code> for each case, along with a <code>SwitchInputHandler</code> that manages reuse of instance and witness values.</div>
</div>
</div>
<div class="sect2">
<h3 id="for-loops">For Loops</h3>
<div class="paragraph">
<p>For loops are where wire-remapping gets <strong>really</strong> tricky, because the remapping indexes change on each iteration, due to iterator-expressions and iterator-expression-ranges
(from now on I will use "expression" synonymously with "iterator-expression" and "iterator-expression range", as a single "iterator-expression" is simply a range with a constant span of 1).
BOLT has three code paths for processing a loop.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Shortcut</strong>, where the well-formedness of its iterations may be extrapolated from its bounds.</p>
</li>
<li>
<p><strong>Soft Unrolling</strong>, where each iteration has its remapping tested individually, but all iterations share the same body.</p>
</li>
<li>
<p><strong>Hard Unrolling</strong>, where each iteration has an individual remapping and body.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Shortcut and soft unrolling can be applied in a hybrid fashion where some expressions are shortcut and others are soft unrolled.
Unfortunately, hard unrolling is an all-or-nothing deal.</p>
</div>
<div class="paragraph">
<p>IR specification compliance can be summarized to a few simple heuristics.
However, the general case requires most of them be checked on each iteration.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Every input wire in every iteration must have been assigned previously.</p>
<div class="ulist">
<ul>
<li>
<p>Assignment could be before the loop,</p>
</li>
<li>
<p>Or in a prior iteration of the loop.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Every output wire in every iteration of the loop must be assignable.</p>
</li>
<li>
<p>The union of all iterations' outputs must be equal to the entire loop&#8217;s outputs.</p>
</li>
<li>
<p>Lastly, either the named function must receive the correct number of inputs and outputs, or the anonymous body must itself be well-formed on all iterations.
Typically, the latter requires that all iterations have the same number of inputs and outputs.</p>
<div class="ulist">
<ul>
<li>
<p>There are some exceptions to having same-sized iterations, however these should be uncommon enough to be penalized by unrolling.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="detecting-shortcuts">Detecting Shortcuts</h4>
<div class="paragraph">
<p>BOLT does its best to come up with specific cases which it can shortcut, and attempts to fall back to unrolling as infrequently as possible.
A trivial shortcut rule is if an input expression is constant and is assigned entirely before the loop.
The non-trivial shortcuts will interpolate a total range (minimum through maximum values) for each expression, and show that the entire range is either referencable for inputs or assignable for outputs.
To do this it has the following conditions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This isn&#8217;t to say that an extrapolation couldn&#8217;t be made with different conditions. These ones happen to be a fairly straight-forward baseline, and to cover many common cases of loops.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">The expression must be a linear expression.</dt>
<dd>
<p>For a linear expression, the expression&#8217;s minimum and maximum values (forming the total range) will occur at a loop bound.
This is also a prerequisite for later conditions.</p>
<div class="ulist">
<ul>
<li>
<p>A sub condition is that evaluation at bounds must not cause integer overflow.
Integer overflow would cause a discontinuity, meaning the minima and maxima may occur on a middle iteration.
Inductively, if a middle iteration causes overflow, then either the next or previous iteration would cause overflow until a bound is met.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">The expression must have the same span at the loops' bounds.</dt>
<dd>
<p>(including combinations of outer-loops' bounds, if the expression depends on outer-loop iterators) If all expressions meet this condition, then each iteration must have the same number of outputs and inputs.</p>
<div class="ulist">
<ul>
<li>
<p>As a sub-condition, the expression&#8217;s span must be 1 or more, to respect well-formedness rules.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">The <em>output</em> expression must have adjacent first and second iterations (or the loop may have only one iteration).</dt>
<dd>
<p>(e.g. <em>i<sub>1</sub>.last == i<sub>2</sub>.first - 1</em> or <em>i<sub>1</sub>.first == i<sub>2</sub>.last + 1</em>) If this is the case, then the expression&#8217;s total range is uninterrupted and can be used to check that the loop&#8217;s outputs are covered.</p>
<div class="ulist">
<ul>
<li>
<p>As a condition of the loop, all output expressions must have disjoint total-ranges, but their union must be equal to the loop&#8217;s output.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">The <em>output</em> expression may depend only on the local loop iterator.</dt>
<dd>
<p>If the loop itself is repeated by an outer loop, then outputs may be remapped correctly in one iteration and incorrectly in another iteration.
Non-dependence on surrounding loop-iterators eliminates that possibility.</p>
</dd>
<dt class="hdlist1">The <em>input</em> expression&#8217;s total range must be assigned before the loop.</dt>
<dd>
<p>When the expression&#8217;s total range is assigned prior to the loop, well-formedness can be checked in the <em>assigned</em> and <em>deleted SkipLists</em>.</p>
<div class="ulist">
<ul>
<li>
<p>Failing this, the <em>input</em> expression&#8217;s total range must intersect with some <em>output</em> expressions ranges.
Both the <em>input</em> expression and the <em>output</em> expressions must be soft unrolled.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
An interesting side-effect of checking all these conditions is that they indicate that each iteration of the loop is independent of the others.
That means that the loop could be parallelized or batch-amortized (however, as-built BOLT is definitely <strong>not</strong> thread-safe).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cutting-corners-on-sequential-loops">Cutting Corners on "Sequential" Loops</h4>
<div class="paragraph">
<p>The last condition of shortcut processing (that <em>input</em> expressions' total ranges must be preassigned) excludes a large class of "sequential" loops which could otherwise shortcut.
In a "sequential" loop, an input expression follows closely behind an output wire, meaning that while it isn&#8217;t <em>pre</em>assigned, it is assigned before use.
These forms can be detected when an <em>input</em> expression&#8217;s total range overlaps an existing <em>output</em> expression&#8217;s total range.
In this case, the following additional conditions allow us to continue shortcut processing rather than soft unrolling.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">The <em>input</em> expression must depend only on the local iterator.</dt>
<dd>
<p>This mirrors the condition of an <em>output</em> expression and assures consistent behavior across iterations of an outer loop.</p>
</dd>
<dt class="hdlist1">The difference between evaluations of <em>output</em> and <em>input</em> expressions at the loop bounds must be the same.</dt>
<dd>
<p>This ensures that both expressions have the same "total span", meaning that one won&#8217;t advance ahead of the other (because we already know that the expressions are linear and have constant span).</p>
</dd>
<dt class="hdlist1">The <em>output</em> and <em>input</em> expressions must "travel" in the same direction</dt>
<dd>
<p>If the expressions were to "travel" in opposite directions, then the <em>input</em> expression would be unassigned until the expressions "crossed their midpoint".</p>
</dd>
<dt class="hdlist1">There must exist a difference between the <em>input</em> and <em>output</em> expression&#8217;s total ranges which is assigned before the loop, and which covers the span of the first iteration of the <em>input</em> expression.</dt>
<dd>
<p>If this preassigned space did not exist, or if it did not cover the first iteration, then the first iteration of the loop would have a poorly formed <em>input</em> expression.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="building-the-shortcut-loop">Building the Shortcut Loop</h4>
<div class="paragraph">
<p>When these conditions are met BOLT builds a single loop body with special wire ranges to self-update on each iteration.
The loop&#8217;s body is a single <code>Bolt</code> object (rather than an <code>Invocation</code> or <code>AnonFunction</code> as <code>SwitchStatement</code> does), essentially inlining any named functions.
This mainly saves on code-complexity, at the occasional expense of memory usage, but it also avoids adding another layer of <code>WireSetWireRangeRef</code>.</p>
</div>
<div class="paragraph">
<p>Each expression is remapped as one of <code>ShortcutLoopIndirectWireRangeRef</code>, <code>ShortcutLoopWireSetWireRangeRef</code>, or, in the case of <em>constant input</em> expressions, remapped as-is.
<code>ShortcutLoop<em>XX</em>WireRangeRef</code>s have a constant range within the inner-scope of the loop, but reevaluate their expression on each iteration of the loop, redefining an offset into the outer-scope.
In most cases the inner-scope range can hold a single pointer to a contiguous outer-scope range ("<em>Indirect</em>").
However, it is possible for an expression to cross between ranges of the outer-scope (say from the input-wires into some local wires), thus a <em>WireSet</em> range must search the entire calling-scope.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/UML_shortcut.png" alt="UML shortcut">
</div>
<div class="title">Figure 7. UML Diagram for Shortcut Loops. Along the left are the <code>ShortcutLoop<em>XX</em>WireRangeRef</code> types. The <code>Expr</code> type, a simple stack-calculator for updating expressions, is defined in the bottom left corner. The <code>ForLoop</code> directive is defined along the bottom.</div>
</div>
</div>
<div class="sect3">
<h4 id="soft-unrolling-path">Soft Unrolling Path</h4>
<div class="paragraph">
<p>Soft unrolling uses some of the same <em>SkipLists</em> from earlier to check the assignment of each wire-range on each loop iteration.
If any of the expressions being unrolled depend on a non-local iterator, then soft unrolling must check the expression at each iteration of the non-local iterator to assure that the inner-loop is well-formed on every iteration of the outer-loop.
Soft unrolling must also check for variable sized inputs or outputs, which would cause BOLT to fall back to hard unrolling.</p>
</div>
<div class="paragraph">
<p>When soft unrolling succeeds, a single <code>SoftLoopWireRangeRef</code> is mapped into the sub-scope.
It holds a vector of <code>Translation</code>s which can be searched to map an inner-scope range to an offset in the outer-scope.
On each iteration of the loop a <code>Mapping</code> must update each <code>Translation</code>, as the span could change.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/UML_soft.png" alt="UML soft">
</div>
<div class="title">Figure 8. UML Diagram for soft unrolled loops. In the bottom left quadrant are the <code>SoftLoopWireRangeRef</code> family with <code>Translation</code> which when given an inner-scope index finds the outer-scope index and <code>Mapping</code> which updates the <code>Translation</code>s on each call to <code>update()</code>.</div>
</div>
</div>
<div class="sect3">
<h4 id="hard-unrolling-path">Hard Unrolling Path</h4>
<div class="paragraph">
<p>In the hard unrolling path, BOLT falls back to a single-pass interpretation scheme.
One property this must maintain is that the build phase is expected to catch any relation well-formedness issues.
For this reason the hard unroll path "pre-executes" the entire loop (repeating for any outer-loops) during the build phase, double-penalizing TA1 for emitting such an obnoxious loop (and myself for allowing such a loop in the IR at all ;-).</p>
</div>
<div class="paragraph">
<p>The main reason that hard unrolling would occur is due to a loop where the output list or input list has non-constant size.
BOLT cannot handle this because the <code>WireRef</code> cannot cache such a dynamic reference.</p>
</div>
<div class="paragraph">
<p>An example of hard unrolling is the "square loop" example.
It is a pair of nested loops.
The inner loop is fairly standard with 100 iterations and assigning its output range in 99, 98 &#8230;&#8203; 0 order.
The outer loop, however, assigns its 100 outputs in 10 iterations, where each iteration&#8217;s output size increases with the iterator&#8217;s square.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$0 ... $99 &lt;- @for i @first 0 @last 9
  // Range is based on square(i), rather than simply i.
  $(i * i) ... $(((i + 1) * (i + 1)) - 1) &lt;- @anon_call(@instance:0, @short_witness:1)
    $100 &lt;- @short_witness;
    // This inner fills some locals and the output list
    $0 ... $99 &lt;- @for j @first 0 @last 99
      $(99 - j) &lt;- @anon_call($(100 - j), @instance:0, @short_witness:0)
        $0 &lt;- @mul($1, $1);
      @end
    @end
  @end
@end</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="the-expr-stack-calculator">The <code>Expr</code> Stack Calculator</h4>
<div class="paragraph">
<p>The <a href="https://github.com/stealthsoftwareinc/wiztoolkit/blob/main/src/main/cpp/wtk/bolt/Expr.cpp#L15"><code>Expr</code> stack calculator</a> updates offsets and mappings in BOLT Loops.
Although this article has used "expression" to refer to an "expression range" the <code>Expr</code> type implements only one bound of the range (e.g. two are needed to represent the entire range).</p>
</div>
<div class="paragraph">
<p>Initially the <code>Expr.eval()</code> method took nearly 50% of BOLT&#8217;s non-ZK runtime, however we were able to optimize this to about 15% to 20%.
Here are a few of its optimization tricks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Passing the stack as a parameter eliminates allocation (faster than even stack-allocation, don&#8217;t ask me why, but C++ doesn&#8217;t like arrays on its stack). This optimization was done to the BOLT Prototype, nearly doubling its speed.</p>
</li>
<li>
<p>"Offset" and "multiple" operations push two parameters to the stack (<code>term.literal</code> and <code>*term.iterator</code>, which were originally union members) before performing either an addition or multiplication. This saves two iterations of the calculator.</p>
</li>
<li>
<p>A common case of the calculator is that it returns after just a single iteration (especially with offset and multiple operations). So we made these a fast-path which skips the stack entirely.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="results">Results</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;re quite pleased with the results from BOLT.
The full-scale system does manage to improve upon the prototype: in the non-ZK setting it managed 4.3s compared to about 5.2s for the matrix 350 circuit, and I believe this was even with a larger prime.
But more important are the metrics with a ZK Backend.
We implemented BOLT&#8217;s callback API using the <a href="https://github.com/emp-toolkit/emp-zk">EMP QuickSilver backend</a>.
When BOLT&#8217;s evaluate phase reaches each gate, it invokes a method from the from the <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/backends.html#the-backend-api"><code>wtk::bolt::Backend</code></a> abstract class.
Child classes can override these methods to perform each gate using ZK.</p>
</div>
<div class="paragraph">
<p>For fair comparison with other approaches we developed the single-pass <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/backends.html#invoking-plasmasnooze">"PLASMASnooze" interpreter</a> (a pun on FIREALARM) which shares backend integrations with BOLT.
We also developed a streaming IR-Simple PLASMASnooze implementation.
As IR-Simple&#8217;s syntax tree is a flat list, each gate can be processed immediately and then discarded, rather than storing it in a parse tree for later traversal.
Lastly we also compare with the <a href="https://github.com/emp-toolkit/emp-ir">EMP C++ compiler</a> which translates the IR to C++.
We&#8217;ve plotted the end to end time (from IR to valid proof) for these approaches using the matrix circuit.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/timing_results_matrix.png" alt="timing results matrix">
</div>
<div class="title">Figure 9. Matrix Circuit EMP Results (Linear time scale from 0 to 110)</div>
</div>
<div class="paragraph">
<p>As expected, the IR-Loops single-pass (teal with crosses) is far slower than the IR-Simple in streaming mode (purple with plus signs).
However the BOLT implementation (blue with stars) is 2x faster than streaming and the C++ implementation (orange with squares) is naturally even faster than that.</p>
</div>
<div class="paragraph">
<p>We also tested against the Finite State Machine circuit created by the T&amp;E Team, which tests IR switch statements.
Unfortunately, we don&#8217;t have an IR-Simple version of this circuit, however we have a few interesting comparisons to make between the IR-Switch FSM circuit and its equivalent after switch statements were converted to multiplex circuits.
Additionally, the EMP backend can improve upon the Fermat multiplexer by creating and checking an additional witness value.
Unfortunately, we had issues compiling larger instances of the FSM circuit with EMP C++, due to <code>gcc</code> running out of RAM.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/wizkit-blog/attachments/bolt/timing_results_fsm.png" alt="timing results fsm">
</div>
<div class="title">Figure 10. Finite State Machine EMP Results (Log time scale from 5 to 12,000 seconds)</div>
</div>
<div class="paragraph">
<p>There are a few interesting takeaways from these test cases.
Most notably, single-pass switch, multi-pass multiplexer, and multi-pass switch are clustered fairly tight (yellow, orange, and green overlaps).
These all took between 8.4 and 8.8ks on the largest test-case.
This indicates that in the multi-pass interpreter the <code>@switch</code> directive is only a marginal improvement over a hard-coded multiplexer.
In the single-pass interpreter, however the <code>@switch</code> directive was extremely effective, going from over 11ks down to about 8.8ks.</p>
</div>
<div class="paragraph">
<p>The most dramatic gain, however, is from replacing the Fermat multiplexer with a witness-checking multiplexer ("EMP-Tricks").
These improve upon the Fermat multiplexer with an approximately 11x speedup.
In this case, the largest test case runs in 826s for the single-pass (aqua with stars) and multi-pass (blue with circles) further improves that by about 10% to 748s.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We designed and developed the BOLT system after noticing that our compact IR-Loop circuits were much slower than their flat/non-uniform equivalents.
We wanted to understand and avoid this slowdown.
The BOLT system accomplished this goal, helping us understand how time was being spent between ZK gates.
In the process, we managed to improve significantly upon flat circuits.
Overall, we hope that following along with our BOLT development has given the reader an appreciation for the overhead spent between ZK gates and some insight into optimizing both ZK circuits and backends.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re interested in using BOLT to speed up your own ZK backend when using the SIEVE IR, have a look at <a href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/backends.html">the WizToolKit tutorial for integrating backends</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087.
The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>
</div>
</div>
</div>
</div>
</div>]]></content><author><name>Kimberlee Model</name></author><category term="SIEVE IR" /><category term="WizToolKit" /><category term="v1.0.1" /><category term="outdated" /><category term="but still super cools" /><summary type="html"><![CDATA[In this installation about the SIEVE IR, we&#8217;re going to talk about speeding up a proof system without changing the underlying zero-knowledge mathemagic. When we time a ZK backend using the IR we inadvertently time two distinct components&#8201;&#8212;&#8201;the backend itself and the time it takes to ingest a circuit. The first component, the backend, is fairly well understood and many groups are working on optimizing this&#8201;&#8212;&#8201;faster math and less communication. The second component is the topic of today&#8217;s post; it&#8217;s the time spent reading a gate and loading its operands before it can be processed in ZK.]]></summary></entry></feed>